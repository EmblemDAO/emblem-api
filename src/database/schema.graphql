"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

"""
A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’
"""
input DatetimeFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Datetime

  """Equal to the specified value."""
  equalTo: Datetime

  """Greater than the specified value."""
  greaterThan: Datetime

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Datetime

  """Included in the specified list."""
  in: [Datetime!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: Datetime

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Datetime

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Datetime

  """Not equal to the specified value."""
  notEqualTo: Datetime

  """Not included in the specified list."""
  notIn: [Datetime!]
}

type Definition implements Node {
  definition: String

  """Reads and enables pagination through a set of `EarnedBadge`."""
  earnedBadgesByDefinitionIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EarnedBadgeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EarnedBadgeFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `EarnedBadge`."""
    orderBy: [EarnedBadgesOrderBy!]
  ): [EarnedBadge!]!
  id: String!
  ipfsUri: String
  metric: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads a single `Protocol` that is related to this `Definition`."""
  protocolByProtocolId: Protocol
  protocolId: String!

  """Reads a single `Role` that is related to this `Definition`."""
  roleByRoleId: Role
  roleId: String
  threshold: String

  """Reads a single `Track` that is related to this `Definition`."""
  trackByTrackId: Track
  trackId: String!
}

"""
A condition to be used against `Definition` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input DefinitionCondition {
  """Checks for equality with the object’s `definition` field."""
  definition: String

  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `ipfsUri` field."""
  ipfsUri: String

  """Checks for equality with the object’s `metric` field."""
  metric: String

  """Checks for equality with the object’s `protocolId` field."""
  protocolId: String

  """Checks for equality with the object’s `roleId` field."""
  roleId: String

  """Checks for equality with the object’s `threshold` field."""
  threshold: String

  """Checks for equality with the object’s `trackId` field."""
  trackId: String
}

"""
A filter to be used against `Definition` object types. All fields are combined with a logical ‘and.’
"""
input DefinitionFilter {
  """Checks for all expressions in this list."""
  and: [DefinitionFilter!]

  """Filter by the object’s `definition` field."""
  definition: StringFilter

  """Filter by the object’s `earnedBadgesByDefinitionIdList` relation."""
  earnedBadgesByDefinitionIdList: DefinitionToManyEarnedBadgeFilter

  """Some related `earnedBadgesByDefinitionIdList` exist."""
  earnedBadgesByDefinitionIdListExist: Boolean

  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `ipfsUri` field."""
  ipfsUri: StringFilter

  """Filter by the object’s `metric` field."""
  metric: StringFilter

  """Negates the expression."""
  not: DefinitionFilter

  """Checks for any expressions in this list."""
  or: [DefinitionFilter!]

  """Filter by the object’s `protocolByProtocolId` relation."""
  protocolByProtocolId: ProtocolFilter

  """Filter by the object’s `protocolId` field."""
  protocolId: StringFilter

  """Filter by the object’s `roleByRoleId` relation."""
  roleByRoleId: RoleFilter

  """A related `roleByRoleId` exists."""
  roleByRoleIdExists: Boolean

  """Filter by the object’s `roleId` field."""
  roleId: StringFilter

  """Filter by the object’s `threshold` field."""
  threshold: StringFilter

  """Filter by the object’s `trackByTrackId` relation."""
  trackByTrackId: TrackFilter

  """Filter by the object’s `trackId` field."""
  trackId: StringFilter
}

"""
A filter to be used against many `EarnedBadge` object types. All fields are combined with a logical ‘and.’
"""
input DefinitionToManyEarnedBadgeFilter {
  """
  Every related `EarnedBadge` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: EarnedBadgeFilter

  """
  No related `EarnedBadge` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: EarnedBadgeFilter

  """
  Some related `EarnedBadge` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: EarnedBadgeFilter
}

"""Methods to use when ordering `Definition`."""
enum DefinitionsOrderBy {
  DEFINITION_ASC
  DEFINITION_DESC
  ID_ASC
  ID_DESC
  IPFS_URI_ASC
  IPFS_URI_DESC
  METRIC_ASC
  METRIC_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PROTOCOL_ID_ASC
  PROTOCOL_ID_DESC
  ROLE_ID_ASC
  ROLE_ID_DESC
  THRESHOLD_ASC
  THRESHOLD_DESC
  TRACK_ID_ASC
  TRACK_ID_DESC
}

type EarnedBadge implements Node {
  awardNumber: Int
  blockAwarded: Int

  """Reads a single `Definition` that is related to this `EarnedBadge`."""
  definitionByDefinitionId: Definition
  definitionId: String!
  globalAwardNumber: Int
  id: String!
  metadata: JSON

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads a single `Protocol` that is related to this `EarnedBadge`."""
  protocolByProtocolId: Protocol
  protocolId: String!
  timestampAwarded: Int
  transactionHash: String

  """Reads a single `Winner` that is related to this `EarnedBadge`."""
  winnerByWinnerId: Winner
  winnerId: String!
}

"""
A condition to be used against `EarnedBadge` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input EarnedBadgeCondition {
  """Checks for equality with the object’s `awardNumber` field."""
  awardNumber: Int

  """Checks for equality with the object’s `blockAwarded` field."""
  blockAwarded: Int

  """Checks for equality with the object’s `definitionId` field."""
  definitionId: String

  """Checks for equality with the object’s `globalAwardNumber` field."""
  globalAwardNumber: Int

  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `metadata` field."""
  metadata: JSON

  """Checks for equality with the object’s `protocolId` field."""
  protocolId: String

  """Checks for equality with the object’s `timestampAwarded` field."""
  timestampAwarded: Int

  """Checks for equality with the object’s `transactionHash` field."""
  transactionHash: String

  """Checks for equality with the object’s `winnerId` field."""
  winnerId: String
}

"""
A filter to be used against `EarnedBadge` object types. All fields are combined with a logical ‘and.’
"""
input EarnedBadgeFilter {
  """Checks for all expressions in this list."""
  and: [EarnedBadgeFilter!]

  """Filter by the object’s `awardNumber` field."""
  awardNumber: IntFilter

  """Filter by the object’s `blockAwarded` field."""
  blockAwarded: IntFilter

  """Filter by the object’s `definitionByDefinitionId` relation."""
  definitionByDefinitionId: DefinitionFilter

  """Filter by the object’s `definitionId` field."""
  definitionId: StringFilter

  """Filter by the object’s `globalAwardNumber` field."""
  globalAwardNumber: IntFilter

  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `metadata` field."""
  metadata: JSONFilter

  """Negates the expression."""
  not: EarnedBadgeFilter

  """Checks for any expressions in this list."""
  or: [EarnedBadgeFilter!]

  """Filter by the object’s `protocolByProtocolId` relation."""
  protocolByProtocolId: ProtocolFilter

  """Filter by the object’s `protocolId` field."""
  protocolId: StringFilter

  """Filter by the object’s `timestampAwarded` field."""
  timestampAwarded: IntFilter

  """Filter by the object’s `transactionHash` field."""
  transactionHash: StringFilter

  """Filter by the object’s `winnerByWinnerId` relation."""
  winnerByWinnerId: WinnerFilter

  """Filter by the object’s `winnerId` field."""
  winnerId: StringFilter
}

"""Methods to use when ordering `EarnedBadge`."""
enum EarnedBadgesOrderBy {
  AWARD_NUMBER_ASC
  AWARD_NUMBER_DESC
  BLOCK_AWARDED_ASC
  BLOCK_AWARDED_DESC
  DEFINITION_ID_ASC
  DEFINITION_ID_DESC
  GLOBAL_AWARD_NUMBER_ASC
  GLOBAL_AWARD_NUMBER_DESC
  ID_ASC
  ID_DESC
  METADATA_ASC
  METADATA_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PROTOCOL_ID_ASC
  PROTOCOL_ID_DESC
  TIMESTAMP_AWARDED_ASC
  TIMESTAMP_AWARDED_DESC
  TRANSACTION_HASH_ASC
  TRANSACTION_HASH_DESC
  WINNER_ID_ASC
  WINNER_ID_DESC
}

"""
A filter to be used against Int fields. All fields are combined with a logical ‘and.’
"""
input IntFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Int

  """Equal to the specified value."""
  equalTo: Int

  """Greater than the specified value."""
  greaterThan: Int

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Int

  """Included in the specified list."""
  in: [Int!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: Int

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Int

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Int

  """Not equal to the specified value."""
  notEqualTo: Int

  """Not included in the specified list."""
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""
A filter to be used against JSON fields. All fields are combined with a logical ‘and.’
"""
input JSONFilter {
  """Contained by the specified JSON."""
  containedBy: JSON

  """Contains the specified JSON."""
  contains: JSON

  """Contains all of the specified keys."""
  containsAllKeys: [String!]

  """Contains any of the specified keys."""
  containsAnyKeys: [String!]

  """Contains the specified key."""
  containsKey: String

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: JSON

  """Equal to the specified value."""
  equalTo: JSON

  """Greater than the specified value."""
  greaterThan: JSON

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: JSON

  """Included in the specified list."""
  in: [JSON!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: JSON

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: JSON

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: JSON

  """Not equal to the specified value."""
  notEqualTo: JSON

  """Not included in the specified list."""
  notIn: [JSON!]
}

type KnexMigration implements Node {
  batch: Int
  id: Int!
  migrationTime: Datetime
  name: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""
A condition to be used against `KnexMigration` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input KnexMigrationCondition {
  """Checks for equality with the object’s `batch` field."""
  batch: Int

  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `migrationTime` field."""
  migrationTime: Datetime

  """Checks for equality with the object’s `name` field."""
  name: String
}

"""
A filter to be used against `KnexMigration` object types. All fields are combined with a logical ‘and.’
"""
input KnexMigrationFilter {
  """Checks for all expressions in this list."""
  and: [KnexMigrationFilter!]

  """Filter by the object’s `batch` field."""
  batch: IntFilter

  """Filter by the object’s `id` field."""
  id: IntFilter

  """Filter by the object’s `migrationTime` field."""
  migrationTime: DatetimeFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: KnexMigrationFilter

  """Checks for any expressions in this list."""
  or: [KnexMigrationFilter!]
}

type KnexMigrationsLock implements Node {
  index: Int!
  isLocked: Int

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""
A condition to be used against `KnexMigrationsLock` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input KnexMigrationsLockCondition {
  """Checks for equality with the object’s `index` field."""
  index: Int

  """Checks for equality with the object’s `isLocked` field."""
  isLocked: Int
}

"""
A filter to be used against `KnexMigrationsLock` object types. All fields are combined with a logical ‘and.’
"""
input KnexMigrationsLockFilter {
  """Checks for all expressions in this list."""
  and: [KnexMigrationsLockFilter!]

  """Filter by the object’s `index` field."""
  index: IntFilter

  """Filter by the object’s `isLocked` field."""
  isLocked: IntFilter

  """Negates the expression."""
  not: KnexMigrationsLockFilter

  """Checks for any expressions in this list."""
  or: [KnexMigrationsLockFilter!]
}

"""Methods to use when ordering `KnexMigrationsLock`."""
enum KnexMigrationsLocksOrderBy {
  INDEX_ASC
  INDEX_DESC
  IS_LOCKED_ASC
  IS_LOCKED_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""Methods to use when ordering `KnexMigration`."""
enum KnexMigrationsOrderBy {
  BATCH_ASC
  BATCH_DESC
  ID_ASC
  ID_DESC
  MIGRATION_TIME_ASC
  MIGRATION_TIME_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

type Protocol implements Node {
  """Reads and enables pagination through a set of `Definition`."""
  definitionsByProtocolIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DefinitionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DefinitionFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Definition`."""
    orderBy: [DefinitionsOrderBy!]
  ): [Definition!]!

  """Reads and enables pagination through a set of `EarnedBadge`."""
  earnedBadgesByProtocolIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EarnedBadgeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EarnedBadgeFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `EarnedBadge`."""
    orderBy: [EarnedBadgesOrderBy!]
  ): [EarnedBadge!]!
  id: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads and enables pagination through a set of `Ranking`."""
  rankingsByProtocolIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RankingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RankingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Ranking`."""
    orderBy: [RankingsOrderBy!]
  ): [Ranking!]!

  """Reads and enables pagination through a set of `Role`."""
  rolesByProtocolIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RoleCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RoleFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Role`."""
    orderBy: [RolesOrderBy!]
  ): [Role!]!

  """Reads and enables pagination through a set of `Track`."""
  tracksByProtocolIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TrackCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TrackFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Track`."""
    orderBy: [TracksOrderBy!]
  ): [Track!]!
}

"""
A condition to be used against `Protocol` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ProtocolCondition {
  """Checks for equality with the object’s `id` field."""
  id: String
}

"""
A filter to be used against `Protocol` object types. All fields are combined with a logical ‘and.’
"""
input ProtocolFilter {
  """Checks for all expressions in this list."""
  and: [ProtocolFilter!]

  """Filter by the object’s `definitionsByProtocolIdList` relation."""
  definitionsByProtocolIdList: ProtocolToManyDefinitionFilter

  """Some related `definitionsByProtocolIdList` exist."""
  definitionsByProtocolIdListExist: Boolean

  """Filter by the object’s `earnedBadgesByProtocolIdList` relation."""
  earnedBadgesByProtocolIdList: ProtocolToManyEarnedBadgeFilter

  """Some related `earnedBadgesByProtocolIdList` exist."""
  earnedBadgesByProtocolIdListExist: Boolean

  """Filter by the object’s `id` field."""
  id: StringFilter

  """Negates the expression."""
  not: ProtocolFilter

  """Checks for any expressions in this list."""
  or: [ProtocolFilter!]

  """Filter by the object’s `rankingsByProtocolIdList` relation."""
  rankingsByProtocolIdList: ProtocolToManyRankingFilter

  """Some related `rankingsByProtocolIdList` exist."""
  rankingsByProtocolIdListExist: Boolean

  """Filter by the object’s `rolesByProtocolIdList` relation."""
  rolesByProtocolIdList: ProtocolToManyRoleFilter

  """Some related `rolesByProtocolIdList` exist."""
  rolesByProtocolIdListExist: Boolean

  """Filter by the object’s `tracksByProtocolIdList` relation."""
  tracksByProtocolIdList: ProtocolToManyTrackFilter

  """Some related `tracksByProtocolIdList` exist."""
  tracksByProtocolIdListExist: Boolean
}

"""
A filter to be used against many `Definition` object types. All fields are combined with a logical ‘and.’
"""
input ProtocolToManyDefinitionFilter {
  """
  Every related `Definition` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: DefinitionFilter

  """
  No related `Definition` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: DefinitionFilter

  """
  Some related `Definition` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: DefinitionFilter
}

"""
A filter to be used against many `EarnedBadge` object types. All fields are combined with a logical ‘and.’
"""
input ProtocolToManyEarnedBadgeFilter {
  """
  Every related `EarnedBadge` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: EarnedBadgeFilter

  """
  No related `EarnedBadge` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: EarnedBadgeFilter

  """
  Some related `EarnedBadge` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: EarnedBadgeFilter
}

"""
A filter to be used against many `Ranking` object types. All fields are combined with a logical ‘and.’
"""
input ProtocolToManyRankingFilter {
  """
  Every related `Ranking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: RankingFilter

  """
  No related `Ranking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: RankingFilter

  """
  Some related `Ranking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: RankingFilter
}

"""
A filter to be used against many `Role` object types. All fields are combined with a logical ‘and.’
"""
input ProtocolToManyRoleFilter {
  """
  Every related `Role` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: RoleFilter

  """
  No related `Role` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: RoleFilter

  """
  Some related `Role` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: RoleFilter
}

"""
A filter to be used against many `Track` object types. All fields are combined with a logical ‘and.’
"""
input ProtocolToManyTrackFilter {
  """
  Every related `Track` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TrackFilter

  """
  No related `Track` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TrackFilter

  """
  Some related `Track` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TrackFilter
}

"""Methods to use when ordering `Protocol`."""
enum ProtocolsOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """Reads a set of `Definition`."""
  allDefinitionsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DefinitionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DefinitionFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Definition`."""
    orderBy: [DefinitionsOrderBy!]
  ): [Definition!]

  """Reads a set of `EarnedBadge`."""
  allEarnedBadgesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EarnedBadgeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EarnedBadgeFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `EarnedBadge`."""
    orderBy: [EarnedBadgesOrderBy!]
  ): [EarnedBadge!]

  """Reads a set of `KnexMigration`."""
  allKnexMigrationsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: KnexMigrationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: KnexMigrationFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `KnexMigration`."""
    orderBy: [KnexMigrationsOrderBy!]
  ): [KnexMigration!]

  """Reads a set of `KnexMigrationsLock`."""
  allKnexMigrationsLocksList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: KnexMigrationsLockCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: KnexMigrationsLockFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `KnexMigrationsLock`."""
    orderBy: [KnexMigrationsLocksOrderBy!]
  ): [KnexMigrationsLock!]

  """Reads a set of `Protocol`."""
  allProtocolsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProtocolCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProtocolFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Protocol`."""
    orderBy: [ProtocolsOrderBy!]
  ): [Protocol!]

  """Reads a set of `Ranking`."""
  allRankingsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RankingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RankingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Ranking`."""
    orderBy: [RankingsOrderBy!]
  ): [Ranking!]

  """Reads a set of `Role`."""
  allRolesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RoleCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RoleFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Role`."""
    orderBy: [RolesOrderBy!]
  ): [Role!]

  """Reads a set of `Track`."""
  allTracksList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TrackCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TrackFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Track`."""
    orderBy: [TracksOrderBy!]
  ): [Track!]

  """Reads a set of `Winner`."""
  allWinnersList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WinnerCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: WinnerFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Winner`."""
    orderBy: [WinnersOrderBy!]
  ): [Winner!]

  """Reads a single `Definition` using its globally unique `ID`."""
  definition(
    """
    The globally unique `ID` to be used in selecting a single `Definition`.
    """
    nodeId: ID!
  ): Definition
  definitionById(id: String!): Definition
  definitionByIdAndProtocolId(id: String!, protocolId: String!): Definition

  """Reads a single `EarnedBadge` using its globally unique `ID`."""
  earnedBadge(
    """
    The globally unique `ID` to be used in selecting a single `EarnedBadge`.
    """
    nodeId: ID!
  ): EarnedBadge
  earnedBadgeById(id: String!): EarnedBadge

  """Reads a single `KnexMigration` using its globally unique `ID`."""
  knexMigration(
    """
    The globally unique `ID` to be used in selecting a single `KnexMigration`.
    """
    nodeId: ID!
  ): KnexMigration
  knexMigrationById(id: Int!): KnexMigration

  """Reads a single `KnexMigrationsLock` using its globally unique `ID`."""
  knexMigrationsLock(
    """
    The globally unique `ID` to be used in selecting a single `KnexMigrationsLock`.
    """
    nodeId: ID!
  ): KnexMigrationsLock
  knexMigrationsLockByIndex(index: Int!): KnexMigrationsLock

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Reads a single `Protocol` using its globally unique `ID`."""
  protocol(
    """The globally unique `ID` to be used in selecting a single `Protocol`."""
    nodeId: ID!
  ): Protocol
  protocolById(id: String!): Protocol

  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """Reads a single `Ranking` using its globally unique `ID`."""
  ranking(
    """The globally unique `ID` to be used in selecting a single `Ranking`."""
    nodeId: ID!
  ): Ranking
  rankingById(id: Int!): Ranking

  """Reads a single `Role` using its globally unique `ID`."""
  role(
    """The globally unique `ID` to be used in selecting a single `Role`."""
    nodeId: ID!
  ): Role
  roleById(id: String!): Role
  roleByIdAndProtocolId(id: String!, protocolId: String!): Role

  """Reads a single `Track` using its globally unique `ID`."""
  track(
    """The globally unique `ID` to be used in selecting a single `Track`."""
    nodeId: ID!
  ): Track
  trackById(id: String!): Track
  trackByIdAndProtocolId(id: String!, protocolId: String!): Track

  """Reads a single `Winner` using its globally unique `ID`."""
  winner(
    """The globally unique `ID` to be used in selecting a single `Winner`."""
    nodeId: ID!
  ): Winner
  winnerById(id: String!): Winner
}

type Ranking implements Node {
  id: Int!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads a single `Protocol` that is related to this `Ranking`."""
  protocolByProtocolId: Protocol
  protocolId: String!
  rank: Int!

  """Reads a single `Winner` that is related to this `Ranking`."""
  winnerByWinnerId: Winner
  winnerId: String!
}

"""
A condition to be used against `Ranking` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input RankingCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `protocolId` field."""
  protocolId: String

  """Checks for equality with the object’s `rank` field."""
  rank: Int

  """Checks for equality with the object’s `winnerId` field."""
  winnerId: String
}

"""
A filter to be used against `Ranking` object types. All fields are combined with a logical ‘and.’
"""
input RankingFilter {
  """Checks for all expressions in this list."""
  and: [RankingFilter!]

  """Filter by the object’s `id` field."""
  id: IntFilter

  """Negates the expression."""
  not: RankingFilter

  """Checks for any expressions in this list."""
  or: [RankingFilter!]

  """Filter by the object’s `protocolByProtocolId` relation."""
  protocolByProtocolId: ProtocolFilter

  """Filter by the object’s `protocolId` field."""
  protocolId: StringFilter

  """Filter by the object’s `rank` field."""
  rank: IntFilter

  """Filter by the object’s `winnerByWinnerId` relation."""
  winnerByWinnerId: WinnerFilter

  """Filter by the object’s `winnerId` field."""
  winnerId: StringFilter
}

"""Methods to use when ordering `Ranking`."""
enum RankingsOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PROTOCOL_ID_ASC
  PROTOCOL_ID_DESC
  RANK_ASC
  RANK_DESC
  WINNER_ID_ASC
  WINNER_ID_DESC
}

type Role implements Node {
  """Reads and enables pagination through a set of `Definition`."""
  definitionsByRoleIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DefinitionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DefinitionFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Definition`."""
    orderBy: [DefinitionsOrderBy!]
  ): [Definition!]!
  id: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads a single `Protocol` that is related to this `Role`."""
  protocolByProtocolId: Protocol
  protocolId: String!
}

"""
A condition to be used against `Role` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input RoleCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `protocolId` field."""
  protocolId: String
}

"""
A filter to be used against `Role` object types. All fields are combined with a logical ‘and.’
"""
input RoleFilter {
  """Checks for all expressions in this list."""
  and: [RoleFilter!]

  """Filter by the object’s `definitionsByRoleIdList` relation."""
  definitionsByRoleIdList: RoleToManyDefinitionFilter

  """Some related `definitionsByRoleIdList` exist."""
  definitionsByRoleIdListExist: Boolean

  """Filter by the object’s `id` field."""
  id: StringFilter

  """Negates the expression."""
  not: RoleFilter

  """Checks for any expressions in this list."""
  or: [RoleFilter!]

  """Filter by the object’s `protocolByProtocolId` relation."""
  protocolByProtocolId: ProtocolFilter

  """Filter by the object’s `protocolId` field."""
  protocolId: StringFilter
}

"""
A filter to be used against many `Definition` object types. All fields are combined with a logical ‘and.’
"""
input RoleToManyDefinitionFilter {
  """
  Every related `Definition` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: DefinitionFilter

  """
  No related `Definition` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: DefinitionFilter

  """
  Some related `Definition` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: DefinitionFilter
}

"""Methods to use when ordering `Role`."""
enum RolesOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PROTOCOL_ID_ASC
  PROTOCOL_ID_DESC
}

"""
A filter to be used against String fields. All fields are combined with a logical ‘and.’
"""
input StringFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String

  """
  Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  distinctFromInsensitive: String

  """Ends with the specified string (case-sensitive)."""
  endsWith: String

  """Ends with the specified string (case-insensitive)."""
  endsWithInsensitive: String

  """Equal to the specified value."""
  equalTo: String

  """Equal to the specified value (case-insensitive)."""
  equalToInsensitive: String

  """Greater than the specified value."""
  greaterThan: String

  """Greater than the specified value (case-insensitive)."""
  greaterThanInsensitive: String

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: String

  """Greater than or equal to the specified value (case-insensitive)."""
  greaterThanOrEqualToInsensitive: String

  """Included in the specified list."""
  in: [String!]

  """Included in the specified list (case-insensitive)."""
  inInsensitive: [String!]

  """Contains the specified string (case-sensitive)."""
  includes: String

  """Contains the specified string (case-insensitive)."""
  includesInsensitive: String

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: String

  """Less than the specified value (case-insensitive)."""
  lessThanInsensitive: String

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: String

  """Less than or equal to the specified value (case-insensitive)."""
  lessThanOrEqualToInsensitive: String

  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String

  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: String

  """
  Equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  notDistinctFromInsensitive: String

  """Does not end with the specified string (case-sensitive)."""
  notEndsWith: String

  """Does not end with the specified string (case-insensitive)."""
  notEndsWithInsensitive: String

  """Not equal to the specified value."""
  notEqualTo: String

  """Not equal to the specified value (case-insensitive)."""
  notEqualToInsensitive: String

  """Not included in the specified list."""
  notIn: [String!]

  """Not included in the specified list (case-insensitive)."""
  notInInsensitive: [String!]

  """Does not contain the specified string (case-sensitive)."""
  notIncludes: String

  """Does not contain the specified string (case-insensitive)."""
  notIncludesInsensitive: String

  """
  Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLike: String

  """
  Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLikeInsensitive: String

  """Does not start with the specified string (case-sensitive)."""
  notStartsWith: String

  """Does not start with the specified string (case-insensitive)."""
  notStartsWithInsensitive: String

  """Starts with the specified string (case-sensitive)."""
  startsWith: String

  """Starts with the specified string (case-insensitive)."""
  startsWithInsensitive: String
}

type Track implements Node {
  """Reads and enables pagination through a set of `Definition`."""
  definitionsByTrackIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DefinitionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DefinitionFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Definition`."""
    orderBy: [DefinitionsOrderBy!]
  ): [Definition!]!
  id: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads a single `Protocol` that is related to this `Track`."""
  protocolByProtocolId: Protocol
  protocolId: String!
}

"""
A condition to be used against `Track` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input TrackCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `protocolId` field."""
  protocolId: String
}

"""
A filter to be used against `Track` object types. All fields are combined with a logical ‘and.’
"""
input TrackFilter {
  """Checks for all expressions in this list."""
  and: [TrackFilter!]

  """Filter by the object’s `definitionsByTrackIdList` relation."""
  definitionsByTrackIdList: TrackToManyDefinitionFilter

  """Some related `definitionsByTrackIdList` exist."""
  definitionsByTrackIdListExist: Boolean

  """Filter by the object’s `id` field."""
  id: StringFilter

  """Negates the expression."""
  not: TrackFilter

  """Checks for any expressions in this list."""
  or: [TrackFilter!]

  """Filter by the object’s `protocolByProtocolId` relation."""
  protocolByProtocolId: ProtocolFilter

  """Filter by the object’s `protocolId` field."""
  protocolId: StringFilter
}

"""
A filter to be used against many `Definition` object types. All fields are combined with a logical ‘and.’
"""
input TrackToManyDefinitionFilter {
  """
  Every related `Definition` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: DefinitionFilter

  """
  No related `Definition` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: DefinitionFilter

  """
  Some related `Definition` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: DefinitionFilter
}

"""Methods to use when ordering `Track`."""
enum TracksOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PROTOCOL_ID_ASC
  PROTOCOL_ID_DESC
}

type Winner implements Node {
  """Reads and enables pagination through a set of `EarnedBadge`."""
  earnedBadgesByWinnerIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EarnedBadgeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EarnedBadgeFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `EarnedBadge`."""
    orderBy: [EarnedBadgesOrderBy!]
  ): [EarnedBadge!]!
  ens: String
  id: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads and enables pagination through a set of `Ranking`."""
  rankingsByWinnerIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RankingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RankingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Ranking`."""
    orderBy: [RankingsOrderBy!]
  ): [Ranking!]!
}

"""
A condition to be used against `Winner` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input WinnerCondition {
  """Checks for equality with the object’s `ens` field."""
  ens: String

  """Checks for equality with the object’s `id` field."""
  id: String
}

"""
A filter to be used against `Winner` object types. All fields are combined with a logical ‘and.’
"""
input WinnerFilter {
  """Checks for all expressions in this list."""
  and: [WinnerFilter!]

  """Filter by the object’s `earnedBadgesByWinnerIdList` relation."""
  earnedBadgesByWinnerIdList: WinnerToManyEarnedBadgeFilter

  """Some related `earnedBadgesByWinnerIdList` exist."""
  earnedBadgesByWinnerIdListExist: Boolean

  """Filter by the object’s `ens` field."""
  ens: StringFilter

  """Filter by the object’s `id` field."""
  id: StringFilter

  """Negates the expression."""
  not: WinnerFilter

  """Checks for any expressions in this list."""
  or: [WinnerFilter!]

  """Filter by the object’s `rankingsByWinnerIdList` relation."""
  rankingsByWinnerIdList: WinnerToManyRankingFilter

  """Some related `rankingsByWinnerIdList` exist."""
  rankingsByWinnerIdListExist: Boolean
}

"""
A filter to be used against many `EarnedBadge` object types. All fields are combined with a logical ‘and.’
"""
input WinnerToManyEarnedBadgeFilter {
  """
  Every related `EarnedBadge` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: EarnedBadgeFilter

  """
  No related `EarnedBadge` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: EarnedBadgeFilter

  """
  Some related `EarnedBadge` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: EarnedBadgeFilter
}

"""
A filter to be used against many `Ranking` object types. All fields are combined with a logical ‘and.’
"""
input WinnerToManyRankingFilter {
  """
  Every related `Ranking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: RankingFilter

  """
  No related `Ranking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: RankingFilter

  """
  Some related `Ranking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: RankingFilter
}

"""Methods to use when ordering `Winner`."""
enum WinnersOrderBy {
  ENS_ASC
  ENS_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}
