"""
A floating point number that requires more precision than IEEE 754 binary 64
"""
scalar BigFloat

"""
A filter to be used against BigFloat fields. All fields are combined with a logical ‘and.’
"""
input BigFloatFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigFloat

  """
  Equal to the specified value.
  """
  equalTo: BigFloat

  """
  Greater than the specified value.
  """
  greaterThan: BigFloat

  """
  Greater than or equal to the specified value.
  """
  greaterThanOrEqualTo: BigFloat

  """
  Included in the specified list.
  """
  in: [BigFloat!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """
  Less than the specified value.
  """
  lessThan: BigFloat

  """
  Less than or equal to the specified value.
  """
  lessThanOrEqualTo: BigFloat

  """
  Equal to the specified value, treating null like an ordinary value.
  """
  notDistinctFrom: BigFloat

  """
  Not equal to the specified value.
  """
  notEqualTo: BigFloat

  """
  Not included in the specified list.
  """
  notIn: [BigFloat!]
}

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

"""
A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’
"""
input BigIntFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigInt

  """
  Equal to the specified value.
  """
  equalTo: BigInt

  """
  Greater than the specified value.
  """
  greaterThan: BigInt

  """
  Greater than or equal to the specified value.
  """
  greaterThanOrEqualTo: BigInt

  """
  Included in the specified list.
  """
  in: [BigInt!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """
  Less than the specified value.
  """
  lessThan: BigInt

  """
  Less than or equal to the specified value.
  """
  lessThanOrEqualTo: BigInt

  """
  Equal to the specified value, treating null like an ordinary value.
  """
  notDistinctFrom: BigInt

  """
  Not equal to the specified value.
  """
  notEqualTo: BigInt

  """
  Not included in the specified list.
  """
  notIn: [BigInt!]
}

"""
A location in a connection that can be used for resuming pagination.
"""
scalar Cursor

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

"""
A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’
"""
input DatetimeFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Datetime

  """
  Equal to the specified value.
  """
  equalTo: Datetime

  """
  Greater than the specified value.
  """
  greaterThan: Datetime

  """
  Greater than or equal to the specified value.
  """
  greaterThanOrEqualTo: Datetime

  """
  Included in the specified list.
  """
  in: [Datetime!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """
  Less than the specified value.
  """
  lessThan: Datetime

  """
  Less than or equal to the specified value.
  """
  lessThanOrEqualTo: Datetime

  """
  Equal to the specified value, treating null like an ordinary value.
  """
  notDistinctFrom: Datetime

  """
  Not equal to the specified value.
  """
  notEqualTo: Datetime

  """
  Not included in the specified list.
  """
  notIn: [Datetime!]
}

type Definition implements Node {
  description: String

  """
  Reads and enables pagination through a set of `EarnedBadge`.
  """
  earnedBadgesByDefinitionId(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EarnedBadgeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EarnedBadgeFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `EarnedBadge`.
    """
    orderBy: [EarnedBadgesOrderBy!] = [PRIMARY_KEY_ASC]
  ): EarnedBadgesConnection!

  """
  Reads and enables pagination through a set of `EarnedBadge`.
  """
  earnedBadgesByDefinitionIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EarnedBadgeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EarnedBadgeFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Skip the first `n` values.
    """
    offset: Int

    """
    The method to use when ordering `EarnedBadge`.
    """
    orderBy: [EarnedBadgesOrderBy!]
  ): [EarnedBadge!]!
  id: String!
  ipfsUri: String
  level: Int
  metric: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Reads a single `Protocol` that is related to this `Definition`.
  """
  protocolByProtocolId: Protocol
  protocolId: String!
  threshold: Float

  """
  Reads a single `Track` that is related to this `Definition`.
  """
  trackByTrackId: Track
  trackId: String!
}

type DefinitionAggregates {
  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: DefinitionAverageAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: DefinitionDistinctCountAggregates
  keys: [String!]

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: DefinitionMaxAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: DefinitionMinAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: DefinitionStddevPopulationAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: DefinitionStddevSampleAggregates

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: DefinitionSumAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: DefinitionVariancePopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: DefinitionVarianceSampleAggregates
}

"""
A filter to be used against aggregates of `Definition` object types.
"""
input DefinitionAggregatesFilter {
  """
  Mean average aggregate over matching `Definition` objects.
  """
  average: DefinitionAverageAggregateFilter

  """
  Distinct count aggregate over matching `Definition` objects.
  """
  distinctCount: DefinitionDistinctCountAggregateFilter

  """
  A filter that must pass for the relevant `Definition` object to be included within the aggregate.
  """
  filter: DefinitionFilter

  """
  Maximum aggregate over matching `Definition` objects.
  """
  max: DefinitionMaxAggregateFilter

  """
  Minimum aggregate over matching `Definition` objects.
  """
  min: DefinitionMinAggregateFilter

  """
  Population standard deviation aggregate over matching `Definition` objects.
  """
  stddevPopulation: DefinitionStddevPopulationAggregateFilter

  """
  Sample standard deviation aggregate over matching `Definition` objects.
  """
  stddevSample: DefinitionStddevSampleAggregateFilter

  """
  Sum aggregate over matching `Definition` objects.
  """
  sum: DefinitionSumAggregateFilter

  """
  Population variance aggregate over matching `Definition` objects.
  """
  variancePopulation: DefinitionVariancePopulationAggregateFilter

  """
  Sample variance aggregate over matching `Definition` objects.
  """
  varianceSample: DefinitionVarianceSampleAggregateFilter
}

input DefinitionAverageAggregateFilter {
  level: BigFloatFilter
  threshold: FloatFilter
}

type DefinitionAverageAggregates {
  """
  Mean average of level across the matching connection
  """
  level: BigFloat

  """
  Mean average of threshold across the matching connection
  """
  threshold: Float
}

"""
A condition to be used against `Definition` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input DefinitionCondition {
  """
  Checks for equality with the object’s `description` field.
  """
  description: String

  """
  Checks for equality with the object’s `id` field.
  """
  id: String

  """
  Checks for equality with the object’s `ipfsUri` field.
  """
  ipfsUri: String

  """
  Checks for equality with the object’s `level` field.
  """
  level: Int

  """
  Checks for equality with the object’s `metric` field.
  """
  metric: String

  """
  Checks for equality with the object’s `protocolId` field.
  """
  protocolId: String

  """
  Checks for equality with the object’s `threshold` field.
  """
  threshold: Float

  """
  Checks for equality with the object’s `trackId` field.
  """
  trackId: String
}

input DefinitionDistinctCountAggregateFilter {
  description: BigIntFilter
  id: BigIntFilter
  ipfsUri: BigIntFilter
  level: BigIntFilter
  metric: BigIntFilter
  protocolId: BigIntFilter
  threshold: BigIntFilter
  trackId: BigIntFilter
}

type DefinitionDistinctCountAggregates {
  """
  Distinct count of description across the matching connection
  """
  description: BigInt

  """
  Distinct count of id across the matching connection
  """
  id: BigInt

  """
  Distinct count of ipfsUri across the matching connection
  """
  ipfsUri: BigInt

  """
  Distinct count of level across the matching connection
  """
  level: BigInt

  """
  Distinct count of metric across the matching connection
  """
  metric: BigInt

  """
  Distinct count of protocolId across the matching connection
  """
  protocolId: BigInt

  """
  Distinct count of threshold across the matching connection
  """
  threshold: BigInt

  """
  Distinct count of trackId across the matching connection
  """
  trackId: BigInt
}

"""
A filter to be used against `Definition` object types. All fields are combined with a logical ‘and.’
"""
input DefinitionFilter {
  """
  Checks for all expressions in this list.
  """
  and: [DefinitionFilter!]

  """
  Filter by the object’s `description` field.
  """
  description: StringFilter

  """
  Filter by the object’s `earnedBadgesByDefinitionId` relation.
  """
  earnedBadgesByDefinitionId: DefinitionToManyEarnedBadgeFilter

  """
  Some related `earnedBadgesByDefinitionId` exist.
  """
  earnedBadgesByDefinitionIdExist: Boolean

  """
  Filter by the object’s `id` field.
  """
  id: StringFilter

  """
  Filter by the object’s `ipfsUri` field.
  """
  ipfsUri: StringFilter

  """
  Filter by the object’s `level` field.
  """
  level: IntFilter

  """
  Filter by the object’s `metric` field.
  """
  metric: StringFilter

  """
  Negates the expression.
  """
  not: DefinitionFilter

  """
  Checks for any expressions in this list.
  """
  or: [DefinitionFilter!]

  """
  Filter by the object’s `protocolByProtocolId` relation.
  """
  protocolByProtocolId: ProtocolFilter

  """
  Filter by the object’s `protocolId` field.
  """
  protocolId: StringFilter

  """
  Filter by the object’s `threshold` field.
  """
  threshold: FloatFilter

  """
  Filter by the object’s `trackByTrackId` relation.
  """
  trackByTrackId: TrackFilter

  """
  Filter by the object’s `trackId` field.
  """
  trackId: StringFilter
}

input DefinitionMaxAggregateFilter {
  level: IntFilter
  threshold: FloatFilter
}

type DefinitionMaxAggregates {
  """
  Maximum of level across the matching connection
  """
  level: Int

  """
  Maximum of threshold across the matching connection
  """
  threshold: Float
}

input DefinitionMinAggregateFilter {
  level: IntFilter
  threshold: FloatFilter
}

type DefinitionMinAggregates {
  """
  Minimum of level across the matching connection
  """
  level: Int

  """
  Minimum of threshold across the matching connection
  """
  threshold: Float
}

input DefinitionStddevPopulationAggregateFilter {
  level: BigFloatFilter
  threshold: FloatFilter
}

type DefinitionStddevPopulationAggregates {
  """
  Population standard deviation of level across the matching connection
  """
  level: BigFloat

  """
  Population standard deviation of threshold across the matching connection
  """
  threshold: Float
}

input DefinitionStddevSampleAggregateFilter {
  level: BigFloatFilter
  threshold: FloatFilter
}

type DefinitionStddevSampleAggregates {
  """
  Sample standard deviation of level across the matching connection
  """
  level: BigFloat

  """
  Sample standard deviation of threshold across the matching connection
  """
  threshold: Float
}

input DefinitionSumAggregateFilter {
  level: BigIntFilter
  threshold: FloatFilter
}

type DefinitionSumAggregates {
  """
  Sum of level across the matching connection
  """
  level: BigInt!

  """
  Sum of threshold across the matching connection
  """
  threshold: Float!
}

"""
A filter to be used against many `EarnedBadge` object types. All fields are combined with a logical ‘and.’
"""
input DefinitionToManyEarnedBadgeFilter {
  """
  Aggregates across related `EarnedBadge` match the filter criteria.
  """
  aggregates: EarnedBadgeAggregatesFilter

  """
  Every related `EarnedBadge` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: EarnedBadgeFilter

  """
  No related `EarnedBadge` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: EarnedBadgeFilter

  """
  Some related `EarnedBadge` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: EarnedBadgeFilter
}

input DefinitionVariancePopulationAggregateFilter {
  level: BigFloatFilter
  threshold: FloatFilter
}

type DefinitionVariancePopulationAggregates {
  """
  Population variance of level across the matching connection
  """
  level: BigFloat

  """
  Population variance of threshold across the matching connection
  """
  threshold: Float
}

input DefinitionVarianceSampleAggregateFilter {
  level: BigFloatFilter
  threshold: FloatFilter
}

type DefinitionVarianceSampleAggregates {
  """
  Sample variance of level across the matching connection
  """
  level: BigFloat

  """
  Sample variance of threshold across the matching connection
  """
  threshold: Float
}

"""
A connection to a list of `Definition` values.
"""
type DefinitionsConnection {
  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: DefinitionAggregates

  """
  A list of edges which contains the `Definition` and cursor to aid in pagination.
  """
  edges: [DefinitionsEdge!]!

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `Definition` for these aggregates.
    """
    groupBy: [DefinitionsGroupBy!]!

    """
    Conditions on the grouped aggregates.
    """
    having: DefinitionsHavingInput
  ): [DefinitionAggregates!]

  """
  A list of `Definition` objects.
  """
  nodes: [Definition!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Definition` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Definition` edge in the connection.
"""
type DefinitionsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Definition` at the end of the edge.
  """
  node: Definition!
}

"""
Grouping methods for `Definition` for usage during aggregation.
"""
enum DefinitionsGroupBy {
  DESCRIPTION
  IPFS_URI
  LEVEL
  METRIC
  PROTOCOL_ID
  THRESHOLD
  TRACK_ID
}

input DefinitionsHavingAverageInput {
  level: HavingIntFilter
  threshold: HavingFloatFilter
}

input DefinitionsHavingDistinctCountInput {
  level: HavingIntFilter
  threshold: HavingFloatFilter
}

"""
Conditions for `Definition` aggregates.
"""
input DefinitionsHavingInput {
  AND: [DefinitionsHavingInput!]
  OR: [DefinitionsHavingInput!]
  average: DefinitionsHavingAverageInput
  distinctCount: DefinitionsHavingDistinctCountInput
  max: DefinitionsHavingMaxInput
  min: DefinitionsHavingMinInput
  stddevPopulation: DefinitionsHavingStddevPopulationInput
  stddevSample: DefinitionsHavingStddevSampleInput
  sum: DefinitionsHavingSumInput
  variancePopulation: DefinitionsHavingVariancePopulationInput
  varianceSample: DefinitionsHavingVarianceSampleInput
}

input DefinitionsHavingMaxInput {
  level: HavingIntFilter
  threshold: HavingFloatFilter
}

input DefinitionsHavingMinInput {
  level: HavingIntFilter
  threshold: HavingFloatFilter
}

input DefinitionsHavingStddevPopulationInput {
  level: HavingIntFilter
  threshold: HavingFloatFilter
}

input DefinitionsHavingStddevSampleInput {
  level: HavingIntFilter
  threshold: HavingFloatFilter
}

input DefinitionsHavingSumInput {
  level: HavingIntFilter
  threshold: HavingFloatFilter
}

input DefinitionsHavingVariancePopulationInput {
  level: HavingIntFilter
  threshold: HavingFloatFilter
}

input DefinitionsHavingVarianceSampleInput {
  level: HavingIntFilter
  threshold: HavingFloatFilter
}

"""
Methods to use when ordering `Definition`.
"""
enum DefinitionsOrderBy {
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  EARNED_BADGES_BY_DEFINITION_ID_AVERAGE_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_DEFINITION_ID_AVERAGE_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_DEFINITION_ID_AVERAGE_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_DEFINITION_ID_AVERAGE_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_DEFINITION_ID_AVERAGE_DEFINITION_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_AVERAGE_DEFINITION_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_AVERAGE_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_DEFINITION_ID_AVERAGE_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_DEFINITION_ID_AVERAGE_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_AVERAGE_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_AVERAGE_METADATA_ASC
  EARNED_BADGES_BY_DEFINITION_ID_AVERAGE_METADATA_DESC
  EARNED_BADGES_BY_DEFINITION_ID_AVERAGE_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_AVERAGE_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_AVERAGE_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_DEFINITION_ID_AVERAGE_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_DEFINITION_ID_AVERAGE_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_DEFINITION_ID_AVERAGE_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_DEFINITION_ID_AVERAGE_WINNER_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_AVERAGE_WINNER_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_COUNT_ASC
  EARNED_BADGES_BY_DEFINITION_ID_COUNT_DESC
  EARNED_BADGES_BY_DEFINITION_ID_DISTINCT_COUNT_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_DEFINITION_ID_DISTINCT_COUNT_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_DEFINITION_ID_DISTINCT_COUNT_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_DEFINITION_ID_DISTINCT_COUNT_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_DEFINITION_ID_DISTINCT_COUNT_DEFINITION_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_DISTINCT_COUNT_DEFINITION_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_DISTINCT_COUNT_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_DEFINITION_ID_DISTINCT_COUNT_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_DEFINITION_ID_DISTINCT_COUNT_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_DISTINCT_COUNT_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_DISTINCT_COUNT_METADATA_ASC
  EARNED_BADGES_BY_DEFINITION_ID_DISTINCT_COUNT_METADATA_DESC
  EARNED_BADGES_BY_DEFINITION_ID_DISTINCT_COUNT_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_DISTINCT_COUNT_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_DISTINCT_COUNT_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_DEFINITION_ID_DISTINCT_COUNT_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_DEFINITION_ID_DISTINCT_COUNT_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_DEFINITION_ID_DISTINCT_COUNT_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_DEFINITION_ID_DISTINCT_COUNT_WINNER_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_DISTINCT_COUNT_WINNER_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_MAX_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_DEFINITION_ID_MAX_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_DEFINITION_ID_MAX_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_DEFINITION_ID_MAX_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_DEFINITION_ID_MAX_DEFINITION_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_MAX_DEFINITION_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_MAX_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_DEFINITION_ID_MAX_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_DEFINITION_ID_MAX_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_MAX_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_MAX_METADATA_ASC
  EARNED_BADGES_BY_DEFINITION_ID_MAX_METADATA_DESC
  EARNED_BADGES_BY_DEFINITION_ID_MAX_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_MAX_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_MAX_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_DEFINITION_ID_MAX_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_DEFINITION_ID_MAX_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_DEFINITION_ID_MAX_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_DEFINITION_ID_MAX_WINNER_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_MAX_WINNER_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_MIN_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_DEFINITION_ID_MIN_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_DEFINITION_ID_MIN_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_DEFINITION_ID_MIN_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_DEFINITION_ID_MIN_DEFINITION_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_MIN_DEFINITION_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_MIN_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_DEFINITION_ID_MIN_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_DEFINITION_ID_MIN_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_MIN_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_MIN_METADATA_ASC
  EARNED_BADGES_BY_DEFINITION_ID_MIN_METADATA_DESC
  EARNED_BADGES_BY_DEFINITION_ID_MIN_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_MIN_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_MIN_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_DEFINITION_ID_MIN_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_DEFINITION_ID_MIN_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_DEFINITION_ID_MIN_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_DEFINITION_ID_MIN_WINNER_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_MIN_WINNER_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_POPULATION_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_POPULATION_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_POPULATION_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_POPULATION_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_POPULATION_DEFINITION_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_POPULATION_DEFINITION_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_POPULATION_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_POPULATION_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_POPULATION_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_POPULATION_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_POPULATION_METADATA_ASC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_POPULATION_METADATA_DESC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_POPULATION_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_POPULATION_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_POPULATION_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_POPULATION_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_POPULATION_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_POPULATION_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_POPULATION_WINNER_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_POPULATION_WINNER_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_SAMPLE_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_SAMPLE_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_SAMPLE_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_SAMPLE_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_SAMPLE_DEFINITION_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_SAMPLE_DEFINITION_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_SAMPLE_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_SAMPLE_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_SAMPLE_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_SAMPLE_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_SAMPLE_METADATA_ASC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_SAMPLE_METADATA_DESC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_SAMPLE_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_SAMPLE_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_SAMPLE_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_SAMPLE_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_SAMPLE_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_SAMPLE_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_SAMPLE_WINNER_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_STDDEV_SAMPLE_WINNER_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_SUM_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_DEFINITION_ID_SUM_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_DEFINITION_ID_SUM_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_DEFINITION_ID_SUM_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_DEFINITION_ID_SUM_DEFINITION_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_SUM_DEFINITION_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_SUM_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_DEFINITION_ID_SUM_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_DEFINITION_ID_SUM_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_SUM_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_SUM_METADATA_ASC
  EARNED_BADGES_BY_DEFINITION_ID_SUM_METADATA_DESC
  EARNED_BADGES_BY_DEFINITION_ID_SUM_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_SUM_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_SUM_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_DEFINITION_ID_SUM_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_DEFINITION_ID_SUM_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_DEFINITION_ID_SUM_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_DEFINITION_ID_SUM_WINNER_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_SUM_WINNER_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_POPULATION_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_POPULATION_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_POPULATION_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_POPULATION_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_POPULATION_DEFINITION_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_POPULATION_DEFINITION_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_POPULATION_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_POPULATION_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_POPULATION_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_POPULATION_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_POPULATION_METADATA_ASC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_POPULATION_METADATA_DESC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_POPULATION_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_POPULATION_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_POPULATION_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_POPULATION_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_POPULATION_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_POPULATION_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_POPULATION_WINNER_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_POPULATION_WINNER_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_SAMPLE_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_SAMPLE_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_SAMPLE_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_SAMPLE_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_SAMPLE_DEFINITION_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_SAMPLE_DEFINITION_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_SAMPLE_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_SAMPLE_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_SAMPLE_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_SAMPLE_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_SAMPLE_METADATA_ASC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_SAMPLE_METADATA_DESC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_SAMPLE_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_SAMPLE_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_SAMPLE_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_SAMPLE_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_SAMPLE_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_SAMPLE_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_SAMPLE_WINNER_ID_ASC
  EARNED_BADGES_BY_DEFINITION_ID_VARIANCE_SAMPLE_WINNER_ID_DESC
  ID_ASC
  ID_DESC
  IPFS_URI_ASC
  IPFS_URI_DESC
  LEVEL_ASC
  LEVEL_DESC
  METRIC_ASC
  METRIC_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PROTOCOL_ID_ASC
  PROTOCOL_ID_DESC
  THRESHOLD_ASC
  THRESHOLD_DESC
  TRACK_ID_ASC
  TRACK_ID_DESC
}

type EarnedBadge implements Node {
  awardNumber: Int
  blockAwarded: Int

  """
  Reads a single `Definition` that is related to this `EarnedBadge`.
  """
  definitionByDefinitionId: Definition
  definitionId: String!
  globalBadgeNumber: Int
  id: String!
  metadata: JSON

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Reads a single `Protocol` that is related to this `EarnedBadge`.
  """
  protocolByProtocolId: Protocol
  protocolId: String!
  timestampAwarded: Int
  transactionHash: String

  """
  Reads a single `Winner` that is related to this `EarnedBadge`.
  """
  winnerByWinnerId: Winner
  winnerId: String!
}

type EarnedBadgeAggregates {
  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: EarnedBadgeAverageAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: EarnedBadgeDistinctCountAggregates
  keys: [String!]

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: EarnedBadgeMaxAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: EarnedBadgeMinAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: EarnedBadgeStddevPopulationAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: EarnedBadgeStddevSampleAggregates

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: EarnedBadgeSumAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: EarnedBadgeVariancePopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: EarnedBadgeVarianceSampleAggregates
}

"""
A filter to be used against aggregates of `EarnedBadge` object types.
"""
input EarnedBadgeAggregatesFilter {
  """
  Mean average aggregate over matching `EarnedBadge` objects.
  """
  average: EarnedBadgeAverageAggregateFilter

  """
  Distinct count aggregate over matching `EarnedBadge` objects.
  """
  distinctCount: EarnedBadgeDistinctCountAggregateFilter

  """
  A filter that must pass for the relevant `EarnedBadge` object to be included within the aggregate.
  """
  filter: EarnedBadgeFilter

  """
  Maximum aggregate over matching `EarnedBadge` objects.
  """
  max: EarnedBadgeMaxAggregateFilter

  """
  Minimum aggregate over matching `EarnedBadge` objects.
  """
  min: EarnedBadgeMinAggregateFilter

  """
  Population standard deviation aggregate over matching `EarnedBadge` objects.
  """
  stddevPopulation: EarnedBadgeStddevPopulationAggregateFilter

  """
  Sample standard deviation aggregate over matching `EarnedBadge` objects.
  """
  stddevSample: EarnedBadgeStddevSampleAggregateFilter

  """
  Sum aggregate over matching `EarnedBadge` objects.
  """
  sum: EarnedBadgeSumAggregateFilter

  """
  Population variance aggregate over matching `EarnedBadge` objects.
  """
  variancePopulation: EarnedBadgeVariancePopulationAggregateFilter

  """
  Sample variance aggregate over matching `EarnedBadge` objects.
  """
  varianceSample: EarnedBadgeVarianceSampleAggregateFilter
}

input EarnedBadgeAverageAggregateFilter {
  awardNumber: BigFloatFilter
  blockAwarded: BigFloatFilter
  globalBadgeNumber: BigFloatFilter
  timestampAwarded: BigFloatFilter
}

type EarnedBadgeAverageAggregates {
  """
  Mean average of awardNumber across the matching connection
  """
  awardNumber: BigFloat

  """
  Mean average of blockAwarded across the matching connection
  """
  blockAwarded: BigFloat

  """
  Mean average of globalBadgeNumber across the matching connection
  """
  globalBadgeNumber: BigFloat

  """
  Mean average of timestampAwarded across the matching connection
  """
  timestampAwarded: BigFloat
}

"""
A condition to be used against `EarnedBadge` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input EarnedBadgeCondition {
  """
  Checks for equality with the object’s `awardNumber` field.
  """
  awardNumber: Int

  """
  Checks for equality with the object’s `blockAwarded` field.
  """
  blockAwarded: Int

  """
  Checks for equality with the object’s `definitionId` field.
  """
  definitionId: String

  """
  Checks for equality with the object’s `globalBadgeNumber` field.
  """
  globalBadgeNumber: Int

  """
  Checks for equality with the object’s `id` field.
  """
  id: String

  """
  Checks for equality with the object’s `metadata` field.
  """
  metadata: JSON

  """
  Checks for equality with the object’s `protocolId` field.
  """
  protocolId: String

  """
  Checks for equality with the object’s `timestampAwarded` field.
  """
  timestampAwarded: Int

  """
  Checks for equality with the object’s `transactionHash` field.
  """
  transactionHash: String

  """
  Checks for equality with the object’s `winnerId` field.
  """
  winnerId: String
}

input EarnedBadgeDistinctCountAggregateFilter {
  awardNumber: BigIntFilter
  blockAwarded: BigIntFilter
  definitionId: BigIntFilter
  globalBadgeNumber: BigIntFilter
  id: BigIntFilter
  metadata: BigIntFilter
  protocolId: BigIntFilter
  timestampAwarded: BigIntFilter
  transactionHash: BigIntFilter
  winnerId: BigIntFilter
}

type EarnedBadgeDistinctCountAggregates {
  """
  Distinct count of awardNumber across the matching connection
  """
  awardNumber: BigInt

  """
  Distinct count of blockAwarded across the matching connection
  """
  blockAwarded: BigInt

  """
  Distinct count of definitionId across the matching connection
  """
  definitionId: BigInt

  """
  Distinct count of globalBadgeNumber across the matching connection
  """
  globalBadgeNumber: BigInt

  """
  Distinct count of id across the matching connection
  """
  id: BigInt

  """
  Distinct count of metadata across the matching connection
  """
  metadata: BigInt

  """
  Distinct count of protocolId across the matching connection
  """
  protocolId: BigInt

  """
  Distinct count of timestampAwarded across the matching connection
  """
  timestampAwarded: BigInt

  """
  Distinct count of transactionHash across the matching connection
  """
  transactionHash: BigInt

  """
  Distinct count of winnerId across the matching connection
  """
  winnerId: BigInt
}

"""
A filter to be used against `EarnedBadge` object types. All fields are combined with a logical ‘and.’
"""
input EarnedBadgeFilter {
  """
  Checks for all expressions in this list.
  """
  and: [EarnedBadgeFilter!]

  """
  Filter by the object’s `awardNumber` field.
  """
  awardNumber: IntFilter

  """
  Filter by the object’s `blockAwarded` field.
  """
  blockAwarded: IntFilter

  """
  Filter by the object’s `definitionByDefinitionId` relation.
  """
  definitionByDefinitionId: DefinitionFilter

  """
  Filter by the object’s `definitionId` field.
  """
  definitionId: StringFilter

  """
  Filter by the object’s `globalBadgeNumber` field.
  """
  globalBadgeNumber: IntFilter

  """
  Filter by the object’s `id` field.
  """
  id: StringFilter

  """
  Filter by the object’s `metadata` field.
  """
  metadata: JSONFilter

  """
  Negates the expression.
  """
  not: EarnedBadgeFilter

  """
  Checks for any expressions in this list.
  """
  or: [EarnedBadgeFilter!]

  """
  Filter by the object’s `protocolByProtocolId` relation.
  """
  protocolByProtocolId: ProtocolFilter

  """
  Filter by the object’s `protocolId` field.
  """
  protocolId: StringFilter

  """
  Filter by the object’s `timestampAwarded` field.
  """
  timestampAwarded: IntFilter

  """
  Filter by the object’s `transactionHash` field.
  """
  transactionHash: StringFilter

  """
  Filter by the object’s `winnerByWinnerId` relation.
  """
  winnerByWinnerId: WinnerFilter

  """
  Filter by the object’s `winnerId` field.
  """
  winnerId: StringFilter
}

input EarnedBadgeMaxAggregateFilter {
  awardNumber: IntFilter
  blockAwarded: IntFilter
  globalBadgeNumber: IntFilter
  timestampAwarded: IntFilter
}

type EarnedBadgeMaxAggregates {
  """
  Maximum of awardNumber across the matching connection
  """
  awardNumber: Int

  """
  Maximum of blockAwarded across the matching connection
  """
  blockAwarded: Int

  """
  Maximum of globalBadgeNumber across the matching connection
  """
  globalBadgeNumber: Int

  """
  Maximum of timestampAwarded across the matching connection
  """
  timestampAwarded: Int
}

input EarnedBadgeMinAggregateFilter {
  awardNumber: IntFilter
  blockAwarded: IntFilter
  globalBadgeNumber: IntFilter
  timestampAwarded: IntFilter
}

type EarnedBadgeMinAggregates {
  """
  Minimum of awardNumber across the matching connection
  """
  awardNumber: Int

  """
  Minimum of blockAwarded across the matching connection
  """
  blockAwarded: Int

  """
  Minimum of globalBadgeNumber across the matching connection
  """
  globalBadgeNumber: Int

  """
  Minimum of timestampAwarded across the matching connection
  """
  timestampAwarded: Int
}

input EarnedBadgeStddevPopulationAggregateFilter {
  awardNumber: BigFloatFilter
  blockAwarded: BigFloatFilter
  globalBadgeNumber: BigFloatFilter
  timestampAwarded: BigFloatFilter
}

type EarnedBadgeStddevPopulationAggregates {
  """
  Population standard deviation of awardNumber across the matching connection
  """
  awardNumber: BigFloat

  """
  Population standard deviation of blockAwarded across the matching connection
  """
  blockAwarded: BigFloat

  """
  Population standard deviation of globalBadgeNumber across the matching connection
  """
  globalBadgeNumber: BigFloat

  """
  Population standard deviation of timestampAwarded across the matching connection
  """
  timestampAwarded: BigFloat
}

input EarnedBadgeStddevSampleAggregateFilter {
  awardNumber: BigFloatFilter
  blockAwarded: BigFloatFilter
  globalBadgeNumber: BigFloatFilter
  timestampAwarded: BigFloatFilter
}

type EarnedBadgeStddevSampleAggregates {
  """
  Sample standard deviation of awardNumber across the matching connection
  """
  awardNumber: BigFloat

  """
  Sample standard deviation of blockAwarded across the matching connection
  """
  blockAwarded: BigFloat

  """
  Sample standard deviation of globalBadgeNumber across the matching connection
  """
  globalBadgeNumber: BigFloat

  """
  Sample standard deviation of timestampAwarded across the matching connection
  """
  timestampAwarded: BigFloat
}

input EarnedBadgeSumAggregateFilter {
  awardNumber: BigIntFilter
  blockAwarded: BigIntFilter
  globalBadgeNumber: BigIntFilter
  timestampAwarded: BigIntFilter
}

type EarnedBadgeSumAggregates {
  """
  Sum of awardNumber across the matching connection
  """
  awardNumber: BigInt!

  """
  Sum of blockAwarded across the matching connection
  """
  blockAwarded: BigInt!

  """
  Sum of globalBadgeNumber across the matching connection
  """
  globalBadgeNumber: BigInt!

  """
  Sum of timestampAwarded across the matching connection
  """
  timestampAwarded: BigInt!
}

input EarnedBadgeVariancePopulationAggregateFilter {
  awardNumber: BigFloatFilter
  blockAwarded: BigFloatFilter
  globalBadgeNumber: BigFloatFilter
  timestampAwarded: BigFloatFilter
}

type EarnedBadgeVariancePopulationAggregates {
  """
  Population variance of awardNumber across the matching connection
  """
  awardNumber: BigFloat

  """
  Population variance of blockAwarded across the matching connection
  """
  blockAwarded: BigFloat

  """
  Population variance of globalBadgeNumber across the matching connection
  """
  globalBadgeNumber: BigFloat

  """
  Population variance of timestampAwarded across the matching connection
  """
  timestampAwarded: BigFloat
}

input EarnedBadgeVarianceSampleAggregateFilter {
  awardNumber: BigFloatFilter
  blockAwarded: BigFloatFilter
  globalBadgeNumber: BigFloatFilter
  timestampAwarded: BigFloatFilter
}

type EarnedBadgeVarianceSampleAggregates {
  """
  Sample variance of awardNumber across the matching connection
  """
  awardNumber: BigFloat

  """
  Sample variance of blockAwarded across the matching connection
  """
  blockAwarded: BigFloat

  """
  Sample variance of globalBadgeNumber across the matching connection
  """
  globalBadgeNumber: BigFloat

  """
  Sample variance of timestampAwarded across the matching connection
  """
  timestampAwarded: BigFloat
}

"""
A connection to a list of `EarnedBadge` values.
"""
type EarnedBadgesConnection {
  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: EarnedBadgeAggregates

  """
  A list of edges which contains the `EarnedBadge` and cursor to aid in pagination.
  """
  edges: [EarnedBadgesEdge!]!

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `EarnedBadge` for these aggregates.
    """
    groupBy: [EarnedBadgesGroupBy!]!

    """
    Conditions on the grouped aggregates.
    """
    having: EarnedBadgesHavingInput
  ): [EarnedBadgeAggregates!]

  """
  A list of `EarnedBadge` objects.
  """
  nodes: [EarnedBadge!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `EarnedBadge` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `EarnedBadge` edge in the connection.
"""
type EarnedBadgesEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `EarnedBadge` at the end of the edge.
  """
  node: EarnedBadge!
}

"""
Grouping methods for `EarnedBadge` for usage during aggregation.
"""
enum EarnedBadgesGroupBy {
  AWARD_NUMBER
  BLOCK_AWARDED
  DEFINITION_ID
  GLOBAL_BADGE_NUMBER
  METADATA
  PROTOCOL_ID
  TIMESTAMP_AWARDED
  TRANSACTION_HASH
  WINNER_ID
}

input EarnedBadgesHavingAverageInput {
  awardNumber: HavingIntFilter
  blockAwarded: HavingIntFilter
  globalBadgeNumber: HavingIntFilter
  timestampAwarded: HavingIntFilter
}

input EarnedBadgesHavingDistinctCountInput {
  awardNumber: HavingIntFilter
  blockAwarded: HavingIntFilter
  globalBadgeNumber: HavingIntFilter
  timestampAwarded: HavingIntFilter
}

"""
Conditions for `EarnedBadge` aggregates.
"""
input EarnedBadgesHavingInput {
  AND: [EarnedBadgesHavingInput!]
  OR: [EarnedBadgesHavingInput!]
  average: EarnedBadgesHavingAverageInput
  distinctCount: EarnedBadgesHavingDistinctCountInput
  max: EarnedBadgesHavingMaxInput
  min: EarnedBadgesHavingMinInput
  stddevPopulation: EarnedBadgesHavingStddevPopulationInput
  stddevSample: EarnedBadgesHavingStddevSampleInput
  sum: EarnedBadgesHavingSumInput
  variancePopulation: EarnedBadgesHavingVariancePopulationInput
  varianceSample: EarnedBadgesHavingVarianceSampleInput
}

input EarnedBadgesHavingMaxInput {
  awardNumber: HavingIntFilter
  blockAwarded: HavingIntFilter
  globalBadgeNumber: HavingIntFilter
  timestampAwarded: HavingIntFilter
}

input EarnedBadgesHavingMinInput {
  awardNumber: HavingIntFilter
  blockAwarded: HavingIntFilter
  globalBadgeNumber: HavingIntFilter
  timestampAwarded: HavingIntFilter
}

input EarnedBadgesHavingStddevPopulationInput {
  awardNumber: HavingIntFilter
  blockAwarded: HavingIntFilter
  globalBadgeNumber: HavingIntFilter
  timestampAwarded: HavingIntFilter
}

input EarnedBadgesHavingStddevSampleInput {
  awardNumber: HavingIntFilter
  blockAwarded: HavingIntFilter
  globalBadgeNumber: HavingIntFilter
  timestampAwarded: HavingIntFilter
}

input EarnedBadgesHavingSumInput {
  awardNumber: HavingIntFilter
  blockAwarded: HavingIntFilter
  globalBadgeNumber: HavingIntFilter
  timestampAwarded: HavingIntFilter
}

input EarnedBadgesHavingVariancePopulationInput {
  awardNumber: HavingIntFilter
  blockAwarded: HavingIntFilter
  globalBadgeNumber: HavingIntFilter
  timestampAwarded: HavingIntFilter
}

input EarnedBadgesHavingVarianceSampleInput {
  awardNumber: HavingIntFilter
  blockAwarded: HavingIntFilter
  globalBadgeNumber: HavingIntFilter
  timestampAwarded: HavingIntFilter
}

"""
Methods to use when ordering `EarnedBadge`.
"""
enum EarnedBadgesOrderBy {
  AWARD_NUMBER_ASC
  AWARD_NUMBER_DESC
  BLOCK_AWARDED_ASC
  BLOCK_AWARDED_DESC
  DEFINITION_ID_ASC
  DEFINITION_ID_DESC
  GLOBAL_BADGE_NUMBER_ASC
  GLOBAL_BADGE_NUMBER_DESC
  ID_ASC
  ID_DESC
  METADATA_ASC
  METADATA_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PROTOCOL_ID_ASC
  PROTOCOL_ID_DESC
  TIMESTAMP_AWARDED_ASC
  TIMESTAMP_AWARDED_DESC
  TRANSACTION_HASH_ASC
  TRANSACTION_HASH_DESC
  WINNER_ID_ASC
  WINNER_ID_DESC
}

"""
A filter to be used against Float fields. All fields are combined with a logical ‘and.’
"""
input FloatFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Float

  """
  Equal to the specified value.
  """
  equalTo: Float

  """
  Greater than the specified value.
  """
  greaterThan: Float

  """
  Greater than or equal to the specified value.
  """
  greaterThanOrEqualTo: Float

  """
  Included in the specified list.
  """
  in: [Float!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """
  Less than the specified value.
  """
  lessThan: Float

  """
  Less than or equal to the specified value.
  """
  lessThanOrEqualTo: Float

  """
  Equal to the specified value, treating null like an ordinary value.
  """
  notDistinctFrom: Float

  """
  Not equal to the specified value.
  """
  notEqualTo: Float

  """
  Not included in the specified list.
  """
  notIn: [Float!]
}

input HavingDatetimeFilter {
  equalTo: Datetime
  greaterThan: Datetime
  greaterThanOrEqualTo: Datetime
  lessThan: Datetime
  lessThanOrEqualTo: Datetime
  notEqualTo: Datetime
}

input HavingFloatFilter {
  equalTo: Float
  greaterThan: Float
  greaterThanOrEqualTo: Float
  lessThan: Float
  lessThanOrEqualTo: Float
  notEqualTo: Float
}

input HavingIntFilter {
  equalTo: Int
  greaterThan: Int
  greaterThanOrEqualTo: Int
  lessThan: Int
  lessThanOrEqualTo: Int
  notEqualTo: Int
}

"""
A filter to be used against Int fields. All fields are combined with a logical ‘and.’
"""
input IntFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Int

  """
  Equal to the specified value.
  """
  equalTo: Int

  """
  Greater than the specified value.
  """
  greaterThan: Int

  """
  Greater than or equal to the specified value.
  """
  greaterThanOrEqualTo: Int

  """
  Included in the specified list.
  """
  in: [Int!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """
  Less than the specified value.
  """
  lessThan: Int

  """
  Less than or equal to the specified value.
  """
  lessThanOrEqualTo: Int

  """
  Equal to the specified value, treating null like an ordinary value.
  """
  notDistinctFrom: Int

  """
  Not equal to the specified value.
  """
  notEqualTo: Int

  """
  Not included in the specified list.
  """
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""
A filter to be used against JSON fields. All fields are combined with a logical ‘and.’
"""
input JSONFilter {
  """
  Contained by the specified JSON.
  """
  containedBy: JSON

  """
  Contains the specified JSON.
  """
  contains: JSON

  """
  Contains all of the specified keys.
  """
  containsAllKeys: [String!]

  """
  Contains any of the specified keys.
  """
  containsAnyKeys: [String!]

  """
  Contains the specified key.
  """
  containsKey: String

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: JSON

  """
  Equal to the specified value.
  """
  equalTo: JSON

  """
  Greater than the specified value.
  """
  greaterThan: JSON

  """
  Greater than or equal to the specified value.
  """
  greaterThanOrEqualTo: JSON

  """
  Included in the specified list.
  """
  in: [JSON!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """
  Less than the specified value.
  """
  lessThan: JSON

  """
  Less than or equal to the specified value.
  """
  lessThanOrEqualTo: JSON

  """
  Equal to the specified value, treating null like an ordinary value.
  """
  notDistinctFrom: JSON

  """
  Not equal to the specified value.
  """
  notEqualTo: JSON

  """
  Not included in the specified list.
  """
  notIn: [JSON!]
}

type KnexMigration implements Node {
  batch: Int
  id: Int!
  migrationTime: Datetime
  name: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

type KnexMigrationAggregates {
  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: KnexMigrationAverageAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: KnexMigrationDistinctCountAggregates
  keys: [String!]

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: KnexMigrationMaxAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: KnexMigrationMinAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: KnexMigrationStddevPopulationAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: KnexMigrationStddevSampleAggregates

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: KnexMigrationSumAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: KnexMigrationVariancePopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: KnexMigrationVarianceSampleAggregates
}

type KnexMigrationAverageAggregates {
  """
  Mean average of batch across the matching connection
  """
  batch: BigFloat

  """
  Mean average of id across the matching connection
  """
  id: BigFloat
}

"""
A condition to be used against `KnexMigration` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input KnexMigrationCondition {
  """
  Checks for equality with the object’s `batch` field.
  """
  batch: Int

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `migrationTime` field.
  """
  migrationTime: Datetime

  """
  Checks for equality with the object’s `name` field.
  """
  name: String
}

type KnexMigrationDistinctCountAggregates {
  """
  Distinct count of batch across the matching connection
  """
  batch: BigInt

  """
  Distinct count of id across the matching connection
  """
  id: BigInt

  """
  Distinct count of migrationTime across the matching connection
  """
  migrationTime: BigInt

  """
  Distinct count of name across the matching connection
  """
  name: BigInt
}

"""
A filter to be used against `KnexMigration` object types. All fields are combined with a logical ‘and.’
"""
input KnexMigrationFilter {
  """
  Checks for all expressions in this list.
  """
  and: [KnexMigrationFilter!]

  """
  Filter by the object’s `batch` field.
  """
  batch: IntFilter

  """
  Filter by the object’s `id` field.
  """
  id: IntFilter

  """
  Filter by the object’s `migrationTime` field.
  """
  migrationTime: DatetimeFilter

  """
  Filter by the object’s `name` field.
  """
  name: StringFilter

  """
  Negates the expression.
  """
  not: KnexMigrationFilter

  """
  Checks for any expressions in this list.
  """
  or: [KnexMigrationFilter!]
}

type KnexMigrationMaxAggregates {
  """
  Maximum of batch across the matching connection
  """
  batch: Int

  """
  Maximum of id across the matching connection
  """
  id: Int
}

type KnexMigrationMinAggregates {
  """
  Minimum of batch across the matching connection
  """
  batch: Int

  """
  Minimum of id across the matching connection
  """
  id: Int
}

type KnexMigrationStddevPopulationAggregates {
  """
  Population standard deviation of batch across the matching connection
  """
  batch: BigFloat

  """
  Population standard deviation of id across the matching connection
  """
  id: BigFloat
}

type KnexMigrationStddevSampleAggregates {
  """
  Sample standard deviation of batch across the matching connection
  """
  batch: BigFloat

  """
  Sample standard deviation of id across the matching connection
  """
  id: BigFloat
}

type KnexMigrationSumAggregates {
  """
  Sum of batch across the matching connection
  """
  batch: BigInt!

  """
  Sum of id across the matching connection
  """
  id: BigInt!
}

type KnexMigrationVariancePopulationAggregates {
  """
  Population variance of batch across the matching connection
  """
  batch: BigFloat

  """
  Population variance of id across the matching connection
  """
  id: BigFloat
}

type KnexMigrationVarianceSampleAggregates {
  """
  Sample variance of batch across the matching connection
  """
  batch: BigFloat

  """
  Sample variance of id across the matching connection
  """
  id: BigFloat
}

"""
A connection to a list of `KnexMigration` values.
"""
type KnexMigrationsConnection {
  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: KnexMigrationAggregates

  """
  A list of edges which contains the `KnexMigration` and cursor to aid in pagination.
  """
  edges: [KnexMigrationsEdge!]!

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `KnexMigration` for these aggregates.
    """
    groupBy: [KnexMigrationsGroupBy!]!

    """
    Conditions on the grouped aggregates.
    """
    having: KnexMigrationsHavingInput
  ): [KnexMigrationAggregates!]

  """
  A list of `KnexMigration` objects.
  """
  nodes: [KnexMigration!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `KnexMigration` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `KnexMigration` edge in the connection.
"""
type KnexMigrationsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `KnexMigration` at the end of the edge.
  """
  node: KnexMigration!
}

"""
Grouping methods for `KnexMigration` for usage during aggregation.
"""
enum KnexMigrationsGroupBy {
  BATCH
  MIGRATION_TIME
  MIGRATION_TIME_TRUNCATED_TO_DAY
  MIGRATION_TIME_TRUNCATED_TO_HOUR
  NAME
}

input KnexMigrationsHavingAverageInput {
  batch: HavingIntFilter
  id: HavingIntFilter
  migrationTime: HavingDatetimeFilter
}

input KnexMigrationsHavingDistinctCountInput {
  batch: HavingIntFilter
  id: HavingIntFilter
  migrationTime: HavingDatetimeFilter
}

"""
Conditions for `KnexMigration` aggregates.
"""
input KnexMigrationsHavingInput {
  AND: [KnexMigrationsHavingInput!]
  OR: [KnexMigrationsHavingInput!]
  average: KnexMigrationsHavingAverageInput
  distinctCount: KnexMigrationsHavingDistinctCountInput
  max: KnexMigrationsHavingMaxInput
  min: KnexMigrationsHavingMinInput
  stddevPopulation: KnexMigrationsHavingStddevPopulationInput
  stddevSample: KnexMigrationsHavingStddevSampleInput
  sum: KnexMigrationsHavingSumInput
  variancePopulation: KnexMigrationsHavingVariancePopulationInput
  varianceSample: KnexMigrationsHavingVarianceSampleInput
}

input KnexMigrationsHavingMaxInput {
  batch: HavingIntFilter
  id: HavingIntFilter
  migrationTime: HavingDatetimeFilter
}

input KnexMigrationsHavingMinInput {
  batch: HavingIntFilter
  id: HavingIntFilter
  migrationTime: HavingDatetimeFilter
}

input KnexMigrationsHavingStddevPopulationInput {
  batch: HavingIntFilter
  id: HavingIntFilter
  migrationTime: HavingDatetimeFilter
}

input KnexMigrationsHavingStddevSampleInput {
  batch: HavingIntFilter
  id: HavingIntFilter
  migrationTime: HavingDatetimeFilter
}

input KnexMigrationsHavingSumInput {
  batch: HavingIntFilter
  id: HavingIntFilter
  migrationTime: HavingDatetimeFilter
}

input KnexMigrationsHavingVariancePopulationInput {
  batch: HavingIntFilter
  id: HavingIntFilter
  migrationTime: HavingDatetimeFilter
}

input KnexMigrationsHavingVarianceSampleInput {
  batch: HavingIntFilter
  id: HavingIntFilter
  migrationTime: HavingDatetimeFilter
}

type KnexMigrationsLock implements Node {
  index: Int!
  isLocked: Int

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

type KnexMigrationsLockAggregates {
  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: KnexMigrationsLockAverageAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: KnexMigrationsLockDistinctCountAggregates
  keys: [String!]

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: KnexMigrationsLockMaxAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: KnexMigrationsLockMinAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: KnexMigrationsLockStddevPopulationAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: KnexMigrationsLockStddevSampleAggregates

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: KnexMigrationsLockSumAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: KnexMigrationsLockVariancePopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: KnexMigrationsLockVarianceSampleAggregates
}

type KnexMigrationsLockAverageAggregates {
  """
  Mean average of index across the matching connection
  """
  index: BigFloat

  """
  Mean average of isLocked across the matching connection
  """
  isLocked: BigFloat
}

"""
A condition to be used against `KnexMigrationsLock` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input KnexMigrationsLockCondition {
  """
  Checks for equality with the object’s `index` field.
  """
  index: Int

  """
  Checks for equality with the object’s `isLocked` field.
  """
  isLocked: Int
}

type KnexMigrationsLockDistinctCountAggregates {
  """
  Distinct count of index across the matching connection
  """
  index: BigInt

  """
  Distinct count of isLocked across the matching connection
  """
  isLocked: BigInt
}

"""
A filter to be used against `KnexMigrationsLock` object types. All fields are combined with a logical ‘and.’
"""
input KnexMigrationsLockFilter {
  """
  Checks for all expressions in this list.
  """
  and: [KnexMigrationsLockFilter!]

  """
  Filter by the object’s `index` field.
  """
  index: IntFilter

  """
  Filter by the object’s `isLocked` field.
  """
  isLocked: IntFilter

  """
  Negates the expression.
  """
  not: KnexMigrationsLockFilter

  """
  Checks for any expressions in this list.
  """
  or: [KnexMigrationsLockFilter!]
}

"""
Grouping methods for `KnexMigrationsLock` for usage during aggregation.
"""
enum KnexMigrationsLockGroupBy {
  IS_LOCKED
}

input KnexMigrationsLockHavingAverageInput {
  index: HavingIntFilter
  isLocked: HavingIntFilter
}

input KnexMigrationsLockHavingDistinctCountInput {
  index: HavingIntFilter
  isLocked: HavingIntFilter
}

"""
Conditions for `KnexMigrationsLock` aggregates.
"""
input KnexMigrationsLockHavingInput {
  AND: [KnexMigrationsLockHavingInput!]
  OR: [KnexMigrationsLockHavingInput!]
  average: KnexMigrationsLockHavingAverageInput
  distinctCount: KnexMigrationsLockHavingDistinctCountInput
  max: KnexMigrationsLockHavingMaxInput
  min: KnexMigrationsLockHavingMinInput
  stddevPopulation: KnexMigrationsLockHavingStddevPopulationInput
  stddevSample: KnexMigrationsLockHavingStddevSampleInput
  sum: KnexMigrationsLockHavingSumInput
  variancePopulation: KnexMigrationsLockHavingVariancePopulationInput
  varianceSample: KnexMigrationsLockHavingVarianceSampleInput
}

input KnexMigrationsLockHavingMaxInput {
  index: HavingIntFilter
  isLocked: HavingIntFilter
}

input KnexMigrationsLockHavingMinInput {
  index: HavingIntFilter
  isLocked: HavingIntFilter
}

input KnexMigrationsLockHavingStddevPopulationInput {
  index: HavingIntFilter
  isLocked: HavingIntFilter
}

input KnexMigrationsLockHavingStddevSampleInput {
  index: HavingIntFilter
  isLocked: HavingIntFilter
}

input KnexMigrationsLockHavingSumInput {
  index: HavingIntFilter
  isLocked: HavingIntFilter
}

input KnexMigrationsLockHavingVariancePopulationInput {
  index: HavingIntFilter
  isLocked: HavingIntFilter
}

input KnexMigrationsLockHavingVarianceSampleInput {
  index: HavingIntFilter
  isLocked: HavingIntFilter
}

type KnexMigrationsLockMaxAggregates {
  """
  Maximum of index across the matching connection
  """
  index: Int

  """
  Maximum of isLocked across the matching connection
  """
  isLocked: Int
}

type KnexMigrationsLockMinAggregates {
  """
  Minimum of index across the matching connection
  """
  index: Int

  """
  Minimum of isLocked across the matching connection
  """
  isLocked: Int
}

type KnexMigrationsLockStddevPopulationAggregates {
  """
  Population standard deviation of index across the matching connection
  """
  index: BigFloat

  """
  Population standard deviation of isLocked across the matching connection
  """
  isLocked: BigFloat
}

type KnexMigrationsLockStddevSampleAggregates {
  """
  Sample standard deviation of index across the matching connection
  """
  index: BigFloat

  """
  Sample standard deviation of isLocked across the matching connection
  """
  isLocked: BigFloat
}

type KnexMigrationsLockSumAggregates {
  """
  Sum of index across the matching connection
  """
  index: BigInt!

  """
  Sum of isLocked across the matching connection
  """
  isLocked: BigInt!
}

type KnexMigrationsLockVariancePopulationAggregates {
  """
  Population variance of index across the matching connection
  """
  index: BigFloat

  """
  Population variance of isLocked across the matching connection
  """
  isLocked: BigFloat
}

type KnexMigrationsLockVarianceSampleAggregates {
  """
  Sample variance of index across the matching connection
  """
  index: BigFloat

  """
  Sample variance of isLocked across the matching connection
  """
  isLocked: BigFloat
}

"""
A connection to a list of `KnexMigrationsLock` values.
"""
type KnexMigrationsLocksConnection {
  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: KnexMigrationsLockAggregates

  """
  A list of edges which contains the `KnexMigrationsLock` and cursor to aid in pagination.
  """
  edges: [KnexMigrationsLocksEdge!]!

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `KnexMigrationsLock` for these aggregates.
    """
    groupBy: [KnexMigrationsLockGroupBy!]!

    """
    Conditions on the grouped aggregates.
    """
    having: KnexMigrationsLockHavingInput
  ): [KnexMigrationsLockAggregates!]

  """
  A list of `KnexMigrationsLock` objects.
  """
  nodes: [KnexMigrationsLock!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `KnexMigrationsLock` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `KnexMigrationsLock` edge in the connection.
"""
type KnexMigrationsLocksEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `KnexMigrationsLock` at the end of the edge.
  """
  node: KnexMigrationsLock!
}

"""
Methods to use when ordering `KnexMigrationsLock`.
"""
enum KnexMigrationsLocksOrderBy {
  INDEX_ASC
  INDEX_DESC
  IS_LOCKED_ASC
  IS_LOCKED_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
Methods to use when ordering `KnexMigration`.
"""
enum KnexMigrationsOrderBy {
  BATCH_ASC
  BATCH_DESC
  ID_ASC
  ID_DESC
  MIGRATION_TIME_ASC
  MIGRATION_TIME_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
An object with a globally unique `ID`.
"""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""
Information about pagination in a connection.
"""
type PageInfo {
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: Cursor

  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!

  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!

  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: Cursor
}

type Protocol implements Node {
  """
  Reads and enables pagination through a set of `Definition`.
  """
  definitionsByProtocolId(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DefinitionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DefinitionFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Definition`.
    """
    orderBy: [DefinitionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): DefinitionsConnection!

  """
  Reads and enables pagination through a set of `Definition`.
  """
  definitionsByProtocolIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DefinitionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DefinitionFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Skip the first `n` values.
    """
    offset: Int

    """
    The method to use when ordering `Definition`.
    """
    orderBy: [DefinitionsOrderBy!]
  ): [Definition!]!

  """
  Reads and enables pagination through a set of `EarnedBadge`.
  """
  earnedBadgesByProtocolId(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EarnedBadgeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EarnedBadgeFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `EarnedBadge`.
    """
    orderBy: [EarnedBadgesOrderBy!] = [PRIMARY_KEY_ASC]
  ): EarnedBadgesConnection!

  """
  Reads and enables pagination through a set of `EarnedBadge`.
  """
  earnedBadgesByProtocolIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EarnedBadgeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EarnedBadgeFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Skip the first `n` values.
    """
    offset: Int

    """
    The method to use when ordering `EarnedBadge`.
    """
    orderBy: [EarnedBadgesOrderBy!]
  ): [EarnedBadge!]!
  id: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Reads and enables pagination through a set of `Ranking`.
  """
  rankingsByProtocolId(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RankingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RankingFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Ranking`.
    """
    orderBy: [RankingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RankingsConnection!

  """
  Reads and enables pagination through a set of `Ranking`.
  """
  rankingsByProtocolIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RankingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RankingFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Skip the first `n` values.
    """
    offset: Int

    """
    The method to use when ordering `Ranking`.
    """
    orderBy: [RankingsOrderBy!]
  ): [Ranking!]!

  """
  Reads and enables pagination through a set of `Role`.
  """
  rolesByProtocolId(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RoleCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RoleFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Role`.
    """
    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RolesConnection!

  """
  Reads and enables pagination through a set of `Role`.
  """
  rolesByProtocolIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RoleCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RoleFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Skip the first `n` values.
    """
    offset: Int

    """
    The method to use when ordering `Role`.
    """
    orderBy: [RolesOrderBy!]
  ): [Role!]!

  """
  Reads and enables pagination through a set of `Track`.
  """
  tracksByProtocolId(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TrackCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TrackFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Track`.
    """
    orderBy: [TracksOrderBy!] = [PRIMARY_KEY_ASC]
  ): TracksConnection!

  """
  Reads and enables pagination through a set of `Track`.
  """
  tracksByProtocolIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TrackCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TrackFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Skip the first `n` values.
    """
    offset: Int

    """
    The method to use when ordering `Track`.
    """
    orderBy: [TracksOrderBy!]
  ): [Track!]!
}

type ProtocolAggregates {
  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: ProtocolDistinctCountAggregates
  keys: [String!]
}

"""
A condition to be used against `Protocol` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ProtocolCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: String
}

type ProtocolDistinctCountAggregates {
  """
  Distinct count of id across the matching connection
  """
  id: BigInt
}

"""
A filter to be used against `Protocol` object types. All fields are combined with a logical ‘and.’
"""
input ProtocolFilter {
  """
  Checks for all expressions in this list.
  """
  and: [ProtocolFilter!]

  """
  Filter by the object’s `definitionsByProtocolId` relation.
  """
  definitionsByProtocolId: ProtocolToManyDefinitionFilter

  """
  Some related `definitionsByProtocolId` exist.
  """
  definitionsByProtocolIdExist: Boolean

  """
  Filter by the object’s `earnedBadgesByProtocolId` relation.
  """
  earnedBadgesByProtocolId: ProtocolToManyEarnedBadgeFilter

  """
  Some related `earnedBadgesByProtocolId` exist.
  """
  earnedBadgesByProtocolIdExist: Boolean

  """
  Filter by the object’s `id` field.
  """
  id: StringFilter

  """
  Negates the expression.
  """
  not: ProtocolFilter

  """
  Checks for any expressions in this list.
  """
  or: [ProtocolFilter!]

  """
  Filter by the object’s `rankingsByProtocolId` relation.
  """
  rankingsByProtocolId: ProtocolToManyRankingFilter

  """
  Some related `rankingsByProtocolId` exist.
  """
  rankingsByProtocolIdExist: Boolean

  """
  Filter by the object’s `rolesByProtocolId` relation.
  """
  rolesByProtocolId: ProtocolToManyRoleFilter

  """
  Some related `rolesByProtocolId` exist.
  """
  rolesByProtocolIdExist: Boolean

  """
  Filter by the object’s `tracksByProtocolId` relation.
  """
  tracksByProtocolId: ProtocolToManyTrackFilter

  """
  Some related `tracksByProtocolId` exist.
  """
  tracksByProtocolIdExist: Boolean
}

"""
A filter to be used against many `Definition` object types. All fields are combined with a logical ‘and.’
"""
input ProtocolToManyDefinitionFilter {
  """
  Aggregates across related `Definition` match the filter criteria.
  """
  aggregates: DefinitionAggregatesFilter

  """
  Every related `Definition` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: DefinitionFilter

  """
  No related `Definition` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: DefinitionFilter

  """
  Some related `Definition` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: DefinitionFilter
}

"""
A filter to be used against many `EarnedBadge` object types. All fields are combined with a logical ‘and.’
"""
input ProtocolToManyEarnedBadgeFilter {
  """
  Aggregates across related `EarnedBadge` match the filter criteria.
  """
  aggregates: EarnedBadgeAggregatesFilter

  """
  Every related `EarnedBadge` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: EarnedBadgeFilter

  """
  No related `EarnedBadge` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: EarnedBadgeFilter

  """
  Some related `EarnedBadge` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: EarnedBadgeFilter
}

"""
A filter to be used against many `Ranking` object types. All fields are combined with a logical ‘and.’
"""
input ProtocolToManyRankingFilter {
  """
  Aggregates across related `Ranking` match the filter criteria.
  """
  aggregates: RankingAggregatesFilter

  """
  Every related `Ranking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: RankingFilter

  """
  No related `Ranking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: RankingFilter

  """
  Some related `Ranking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: RankingFilter
}

"""
A filter to be used against many `Role` object types. All fields are combined with a logical ‘and.’
"""
input ProtocolToManyRoleFilter {
  """
  Aggregates across related `Role` match the filter criteria.
  """
  aggregates: RoleAggregatesFilter

  """
  Every related `Role` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: RoleFilter

  """
  No related `Role` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: RoleFilter

  """
  Some related `Role` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: RoleFilter
}

"""
A filter to be used against many `Track` object types. All fields are combined with a logical ‘and.’
"""
input ProtocolToManyTrackFilter {
  """
  Aggregates across related `Track` match the filter criteria.
  """
  aggregates: TrackAggregatesFilter

  """
  Every related `Track` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TrackFilter

  """
  No related `Track` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TrackFilter

  """
  Some related `Track` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TrackFilter
}

"""
A connection to a list of `Protocol` values.
"""
type ProtocolsConnection {
  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: ProtocolAggregates

  """
  A list of edges which contains the `Protocol` and cursor to aid in pagination.
  """
  edges: [ProtocolsEdge!]!

  """
  A list of `Protocol` objects.
  """
  nodes: [Protocol!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Protocol` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Protocol` edge in the connection.
"""
type ProtocolsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Protocol` at the end of the edge.
  """
  node: Protocol!
}

"""
Methods to use when ordering `Protocol`.
"""
enum ProtocolsOrderBy {
  DEFINITIONS_BY_PROTOCOL_ID_AVERAGE_DESCRIPTION_ASC
  DEFINITIONS_BY_PROTOCOL_ID_AVERAGE_DESCRIPTION_DESC
  DEFINITIONS_BY_PROTOCOL_ID_AVERAGE_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_AVERAGE_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_AVERAGE_IPFS_URI_ASC
  DEFINITIONS_BY_PROTOCOL_ID_AVERAGE_IPFS_URI_DESC
  DEFINITIONS_BY_PROTOCOL_ID_AVERAGE_LEVEL_ASC
  DEFINITIONS_BY_PROTOCOL_ID_AVERAGE_LEVEL_DESC
  DEFINITIONS_BY_PROTOCOL_ID_AVERAGE_METRIC_ASC
  DEFINITIONS_BY_PROTOCOL_ID_AVERAGE_METRIC_DESC
  DEFINITIONS_BY_PROTOCOL_ID_AVERAGE_PROTOCOL_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_AVERAGE_PROTOCOL_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_AVERAGE_THRESHOLD_ASC
  DEFINITIONS_BY_PROTOCOL_ID_AVERAGE_THRESHOLD_DESC
  DEFINITIONS_BY_PROTOCOL_ID_AVERAGE_TRACK_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_AVERAGE_TRACK_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_COUNT_ASC
  DEFINITIONS_BY_PROTOCOL_ID_COUNT_DESC
  DEFINITIONS_BY_PROTOCOL_ID_DISTINCT_COUNT_DESCRIPTION_ASC
  DEFINITIONS_BY_PROTOCOL_ID_DISTINCT_COUNT_DESCRIPTION_DESC
  DEFINITIONS_BY_PROTOCOL_ID_DISTINCT_COUNT_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_DISTINCT_COUNT_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_DISTINCT_COUNT_IPFS_URI_ASC
  DEFINITIONS_BY_PROTOCOL_ID_DISTINCT_COUNT_IPFS_URI_DESC
  DEFINITIONS_BY_PROTOCOL_ID_DISTINCT_COUNT_LEVEL_ASC
  DEFINITIONS_BY_PROTOCOL_ID_DISTINCT_COUNT_LEVEL_DESC
  DEFINITIONS_BY_PROTOCOL_ID_DISTINCT_COUNT_METRIC_ASC
  DEFINITIONS_BY_PROTOCOL_ID_DISTINCT_COUNT_METRIC_DESC
  DEFINITIONS_BY_PROTOCOL_ID_DISTINCT_COUNT_PROTOCOL_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_DISTINCT_COUNT_PROTOCOL_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_DISTINCT_COUNT_THRESHOLD_ASC
  DEFINITIONS_BY_PROTOCOL_ID_DISTINCT_COUNT_THRESHOLD_DESC
  DEFINITIONS_BY_PROTOCOL_ID_DISTINCT_COUNT_TRACK_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_DISTINCT_COUNT_TRACK_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_MAX_DESCRIPTION_ASC
  DEFINITIONS_BY_PROTOCOL_ID_MAX_DESCRIPTION_DESC
  DEFINITIONS_BY_PROTOCOL_ID_MAX_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_MAX_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_MAX_IPFS_URI_ASC
  DEFINITIONS_BY_PROTOCOL_ID_MAX_IPFS_URI_DESC
  DEFINITIONS_BY_PROTOCOL_ID_MAX_LEVEL_ASC
  DEFINITIONS_BY_PROTOCOL_ID_MAX_LEVEL_DESC
  DEFINITIONS_BY_PROTOCOL_ID_MAX_METRIC_ASC
  DEFINITIONS_BY_PROTOCOL_ID_MAX_METRIC_DESC
  DEFINITIONS_BY_PROTOCOL_ID_MAX_PROTOCOL_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_MAX_PROTOCOL_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_MAX_THRESHOLD_ASC
  DEFINITIONS_BY_PROTOCOL_ID_MAX_THRESHOLD_DESC
  DEFINITIONS_BY_PROTOCOL_ID_MAX_TRACK_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_MAX_TRACK_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_MIN_DESCRIPTION_ASC
  DEFINITIONS_BY_PROTOCOL_ID_MIN_DESCRIPTION_DESC
  DEFINITIONS_BY_PROTOCOL_ID_MIN_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_MIN_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_MIN_IPFS_URI_ASC
  DEFINITIONS_BY_PROTOCOL_ID_MIN_IPFS_URI_DESC
  DEFINITIONS_BY_PROTOCOL_ID_MIN_LEVEL_ASC
  DEFINITIONS_BY_PROTOCOL_ID_MIN_LEVEL_DESC
  DEFINITIONS_BY_PROTOCOL_ID_MIN_METRIC_ASC
  DEFINITIONS_BY_PROTOCOL_ID_MIN_METRIC_DESC
  DEFINITIONS_BY_PROTOCOL_ID_MIN_PROTOCOL_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_MIN_PROTOCOL_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_MIN_THRESHOLD_ASC
  DEFINITIONS_BY_PROTOCOL_ID_MIN_THRESHOLD_DESC
  DEFINITIONS_BY_PROTOCOL_ID_MIN_TRACK_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_MIN_TRACK_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_POPULATION_DESCRIPTION_ASC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_POPULATION_DESCRIPTION_DESC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_POPULATION_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_POPULATION_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_POPULATION_IPFS_URI_ASC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_POPULATION_IPFS_URI_DESC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_POPULATION_LEVEL_ASC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_POPULATION_LEVEL_DESC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_POPULATION_METRIC_ASC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_POPULATION_METRIC_DESC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_POPULATION_PROTOCOL_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_POPULATION_PROTOCOL_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_POPULATION_THRESHOLD_ASC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_POPULATION_THRESHOLD_DESC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_POPULATION_TRACK_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_POPULATION_TRACK_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_SAMPLE_DESCRIPTION_ASC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_SAMPLE_DESCRIPTION_DESC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_SAMPLE_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_SAMPLE_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_SAMPLE_IPFS_URI_ASC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_SAMPLE_IPFS_URI_DESC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_SAMPLE_LEVEL_ASC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_SAMPLE_LEVEL_DESC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_SAMPLE_METRIC_ASC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_SAMPLE_METRIC_DESC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_SAMPLE_PROTOCOL_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_SAMPLE_PROTOCOL_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_SAMPLE_THRESHOLD_ASC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_SAMPLE_THRESHOLD_DESC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_SAMPLE_TRACK_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_STDDEV_SAMPLE_TRACK_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_SUM_DESCRIPTION_ASC
  DEFINITIONS_BY_PROTOCOL_ID_SUM_DESCRIPTION_DESC
  DEFINITIONS_BY_PROTOCOL_ID_SUM_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_SUM_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_SUM_IPFS_URI_ASC
  DEFINITIONS_BY_PROTOCOL_ID_SUM_IPFS_URI_DESC
  DEFINITIONS_BY_PROTOCOL_ID_SUM_LEVEL_ASC
  DEFINITIONS_BY_PROTOCOL_ID_SUM_LEVEL_DESC
  DEFINITIONS_BY_PROTOCOL_ID_SUM_METRIC_ASC
  DEFINITIONS_BY_PROTOCOL_ID_SUM_METRIC_DESC
  DEFINITIONS_BY_PROTOCOL_ID_SUM_PROTOCOL_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_SUM_PROTOCOL_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_SUM_THRESHOLD_ASC
  DEFINITIONS_BY_PROTOCOL_ID_SUM_THRESHOLD_DESC
  DEFINITIONS_BY_PROTOCOL_ID_SUM_TRACK_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_SUM_TRACK_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_POPULATION_DESCRIPTION_ASC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_POPULATION_DESCRIPTION_DESC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_POPULATION_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_POPULATION_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_POPULATION_IPFS_URI_ASC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_POPULATION_IPFS_URI_DESC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_POPULATION_LEVEL_ASC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_POPULATION_LEVEL_DESC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_POPULATION_METRIC_ASC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_POPULATION_METRIC_DESC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_POPULATION_PROTOCOL_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_POPULATION_PROTOCOL_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_POPULATION_THRESHOLD_ASC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_POPULATION_THRESHOLD_DESC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_POPULATION_TRACK_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_POPULATION_TRACK_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_DESCRIPTION_ASC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_DESCRIPTION_DESC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_IPFS_URI_ASC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_IPFS_URI_DESC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_LEVEL_ASC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_LEVEL_DESC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_METRIC_ASC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_METRIC_DESC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_PROTOCOL_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_PROTOCOL_ID_DESC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_THRESHOLD_ASC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_THRESHOLD_DESC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_TRACK_ID_ASC
  DEFINITIONS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_TRACK_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_AVERAGE_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_AVERAGE_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_AVERAGE_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_AVERAGE_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_AVERAGE_DEFINITION_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_AVERAGE_DEFINITION_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_AVERAGE_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_AVERAGE_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_AVERAGE_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_AVERAGE_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_AVERAGE_METADATA_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_AVERAGE_METADATA_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_AVERAGE_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_AVERAGE_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_AVERAGE_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_AVERAGE_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_AVERAGE_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_AVERAGE_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_AVERAGE_WINNER_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_AVERAGE_WINNER_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_COUNT_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_COUNT_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_DISTINCT_COUNT_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_DISTINCT_COUNT_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_DISTINCT_COUNT_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_DISTINCT_COUNT_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_DISTINCT_COUNT_DEFINITION_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_DISTINCT_COUNT_DEFINITION_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_DISTINCT_COUNT_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_DISTINCT_COUNT_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_DISTINCT_COUNT_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_DISTINCT_COUNT_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_DISTINCT_COUNT_METADATA_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_DISTINCT_COUNT_METADATA_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_DISTINCT_COUNT_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_DISTINCT_COUNT_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_DISTINCT_COUNT_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_DISTINCT_COUNT_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_DISTINCT_COUNT_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_DISTINCT_COUNT_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_DISTINCT_COUNT_WINNER_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_DISTINCT_COUNT_WINNER_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_MAX_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_MAX_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_MAX_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_MAX_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_MAX_DEFINITION_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_MAX_DEFINITION_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_MAX_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_MAX_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_MAX_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_MAX_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_MAX_METADATA_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_MAX_METADATA_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_MAX_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_MAX_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_MAX_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_MAX_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_MAX_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_MAX_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_MAX_WINNER_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_MAX_WINNER_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_MIN_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_MIN_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_MIN_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_MIN_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_MIN_DEFINITION_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_MIN_DEFINITION_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_MIN_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_MIN_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_MIN_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_MIN_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_MIN_METADATA_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_MIN_METADATA_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_MIN_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_MIN_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_MIN_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_MIN_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_MIN_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_MIN_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_MIN_WINNER_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_MIN_WINNER_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_POPULATION_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_POPULATION_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_POPULATION_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_POPULATION_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_POPULATION_DEFINITION_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_POPULATION_DEFINITION_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_POPULATION_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_POPULATION_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_POPULATION_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_POPULATION_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_POPULATION_METADATA_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_POPULATION_METADATA_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_POPULATION_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_POPULATION_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_POPULATION_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_POPULATION_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_POPULATION_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_POPULATION_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_POPULATION_WINNER_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_POPULATION_WINNER_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_SAMPLE_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_SAMPLE_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_SAMPLE_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_SAMPLE_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_SAMPLE_DEFINITION_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_SAMPLE_DEFINITION_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_SAMPLE_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_SAMPLE_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_SAMPLE_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_SAMPLE_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_SAMPLE_METADATA_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_SAMPLE_METADATA_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_SAMPLE_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_SAMPLE_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_SAMPLE_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_SAMPLE_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_SAMPLE_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_SAMPLE_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_SAMPLE_WINNER_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_STDDEV_SAMPLE_WINNER_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_SUM_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_SUM_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_SUM_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_SUM_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_SUM_DEFINITION_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_SUM_DEFINITION_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_SUM_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_SUM_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_SUM_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_SUM_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_SUM_METADATA_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_SUM_METADATA_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_SUM_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_SUM_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_SUM_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_SUM_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_SUM_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_SUM_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_SUM_WINNER_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_SUM_WINNER_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_POPULATION_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_POPULATION_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_POPULATION_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_POPULATION_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_POPULATION_DEFINITION_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_POPULATION_DEFINITION_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_POPULATION_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_POPULATION_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_POPULATION_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_POPULATION_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_POPULATION_METADATA_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_POPULATION_METADATA_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_POPULATION_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_POPULATION_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_POPULATION_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_POPULATION_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_POPULATION_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_POPULATION_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_POPULATION_WINNER_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_POPULATION_WINNER_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_DEFINITION_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_DEFINITION_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_METADATA_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_METADATA_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_WINNER_ID_ASC
  EARNED_BADGES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_WINNER_ID_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RANKINGS_BY_PROTOCOL_ID_AVERAGE_PROTOCOL_ID_ASC
  RANKINGS_BY_PROTOCOL_ID_AVERAGE_PROTOCOL_ID_DESC
  RANKINGS_BY_PROTOCOL_ID_AVERAGE_RANK_ASC
  RANKINGS_BY_PROTOCOL_ID_AVERAGE_RANK_DESC
  RANKINGS_BY_PROTOCOL_ID_AVERAGE_WINNER_ID_ASC
  RANKINGS_BY_PROTOCOL_ID_AVERAGE_WINNER_ID_DESC
  RANKINGS_BY_PROTOCOL_ID_COUNT_ASC
  RANKINGS_BY_PROTOCOL_ID_COUNT_DESC
  RANKINGS_BY_PROTOCOL_ID_DISTINCT_COUNT_PROTOCOL_ID_ASC
  RANKINGS_BY_PROTOCOL_ID_DISTINCT_COUNT_PROTOCOL_ID_DESC
  RANKINGS_BY_PROTOCOL_ID_DISTINCT_COUNT_RANK_ASC
  RANKINGS_BY_PROTOCOL_ID_DISTINCT_COUNT_RANK_DESC
  RANKINGS_BY_PROTOCOL_ID_DISTINCT_COUNT_WINNER_ID_ASC
  RANKINGS_BY_PROTOCOL_ID_DISTINCT_COUNT_WINNER_ID_DESC
  RANKINGS_BY_PROTOCOL_ID_MAX_PROTOCOL_ID_ASC
  RANKINGS_BY_PROTOCOL_ID_MAX_PROTOCOL_ID_DESC
  RANKINGS_BY_PROTOCOL_ID_MAX_RANK_ASC
  RANKINGS_BY_PROTOCOL_ID_MAX_RANK_DESC
  RANKINGS_BY_PROTOCOL_ID_MAX_WINNER_ID_ASC
  RANKINGS_BY_PROTOCOL_ID_MAX_WINNER_ID_DESC
  RANKINGS_BY_PROTOCOL_ID_MIN_PROTOCOL_ID_ASC
  RANKINGS_BY_PROTOCOL_ID_MIN_PROTOCOL_ID_DESC
  RANKINGS_BY_PROTOCOL_ID_MIN_RANK_ASC
  RANKINGS_BY_PROTOCOL_ID_MIN_RANK_DESC
  RANKINGS_BY_PROTOCOL_ID_MIN_WINNER_ID_ASC
  RANKINGS_BY_PROTOCOL_ID_MIN_WINNER_ID_DESC
  RANKINGS_BY_PROTOCOL_ID_STDDEV_POPULATION_PROTOCOL_ID_ASC
  RANKINGS_BY_PROTOCOL_ID_STDDEV_POPULATION_PROTOCOL_ID_DESC
  RANKINGS_BY_PROTOCOL_ID_STDDEV_POPULATION_RANK_ASC
  RANKINGS_BY_PROTOCOL_ID_STDDEV_POPULATION_RANK_DESC
  RANKINGS_BY_PROTOCOL_ID_STDDEV_POPULATION_WINNER_ID_ASC
  RANKINGS_BY_PROTOCOL_ID_STDDEV_POPULATION_WINNER_ID_DESC
  RANKINGS_BY_PROTOCOL_ID_STDDEV_SAMPLE_PROTOCOL_ID_ASC
  RANKINGS_BY_PROTOCOL_ID_STDDEV_SAMPLE_PROTOCOL_ID_DESC
  RANKINGS_BY_PROTOCOL_ID_STDDEV_SAMPLE_RANK_ASC
  RANKINGS_BY_PROTOCOL_ID_STDDEV_SAMPLE_RANK_DESC
  RANKINGS_BY_PROTOCOL_ID_STDDEV_SAMPLE_WINNER_ID_ASC
  RANKINGS_BY_PROTOCOL_ID_STDDEV_SAMPLE_WINNER_ID_DESC
  RANKINGS_BY_PROTOCOL_ID_SUM_PROTOCOL_ID_ASC
  RANKINGS_BY_PROTOCOL_ID_SUM_PROTOCOL_ID_DESC
  RANKINGS_BY_PROTOCOL_ID_SUM_RANK_ASC
  RANKINGS_BY_PROTOCOL_ID_SUM_RANK_DESC
  RANKINGS_BY_PROTOCOL_ID_SUM_WINNER_ID_ASC
  RANKINGS_BY_PROTOCOL_ID_SUM_WINNER_ID_DESC
  RANKINGS_BY_PROTOCOL_ID_VARIANCE_POPULATION_PROTOCOL_ID_ASC
  RANKINGS_BY_PROTOCOL_ID_VARIANCE_POPULATION_PROTOCOL_ID_DESC
  RANKINGS_BY_PROTOCOL_ID_VARIANCE_POPULATION_RANK_ASC
  RANKINGS_BY_PROTOCOL_ID_VARIANCE_POPULATION_RANK_DESC
  RANKINGS_BY_PROTOCOL_ID_VARIANCE_POPULATION_WINNER_ID_ASC
  RANKINGS_BY_PROTOCOL_ID_VARIANCE_POPULATION_WINNER_ID_DESC
  RANKINGS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_PROTOCOL_ID_ASC
  RANKINGS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_PROTOCOL_ID_DESC
  RANKINGS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_RANK_ASC
  RANKINGS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_RANK_DESC
  RANKINGS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_WINNER_ID_ASC
  RANKINGS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_WINNER_ID_DESC
  ROLES_BY_PROTOCOL_ID_AVERAGE_ID_ASC
  ROLES_BY_PROTOCOL_ID_AVERAGE_ID_DESC
  ROLES_BY_PROTOCOL_ID_AVERAGE_PROTOCOL_ID_ASC
  ROLES_BY_PROTOCOL_ID_AVERAGE_PROTOCOL_ID_DESC
  ROLES_BY_PROTOCOL_ID_COUNT_ASC
  ROLES_BY_PROTOCOL_ID_COUNT_DESC
  ROLES_BY_PROTOCOL_ID_DISTINCT_COUNT_ID_ASC
  ROLES_BY_PROTOCOL_ID_DISTINCT_COUNT_ID_DESC
  ROLES_BY_PROTOCOL_ID_DISTINCT_COUNT_PROTOCOL_ID_ASC
  ROLES_BY_PROTOCOL_ID_DISTINCT_COUNT_PROTOCOL_ID_DESC
  ROLES_BY_PROTOCOL_ID_MAX_ID_ASC
  ROLES_BY_PROTOCOL_ID_MAX_ID_DESC
  ROLES_BY_PROTOCOL_ID_MAX_PROTOCOL_ID_ASC
  ROLES_BY_PROTOCOL_ID_MAX_PROTOCOL_ID_DESC
  ROLES_BY_PROTOCOL_ID_MIN_ID_ASC
  ROLES_BY_PROTOCOL_ID_MIN_ID_DESC
  ROLES_BY_PROTOCOL_ID_MIN_PROTOCOL_ID_ASC
  ROLES_BY_PROTOCOL_ID_MIN_PROTOCOL_ID_DESC
  ROLES_BY_PROTOCOL_ID_STDDEV_POPULATION_ID_ASC
  ROLES_BY_PROTOCOL_ID_STDDEV_POPULATION_ID_DESC
  ROLES_BY_PROTOCOL_ID_STDDEV_POPULATION_PROTOCOL_ID_ASC
  ROLES_BY_PROTOCOL_ID_STDDEV_POPULATION_PROTOCOL_ID_DESC
  ROLES_BY_PROTOCOL_ID_STDDEV_SAMPLE_ID_ASC
  ROLES_BY_PROTOCOL_ID_STDDEV_SAMPLE_ID_DESC
  ROLES_BY_PROTOCOL_ID_STDDEV_SAMPLE_PROTOCOL_ID_ASC
  ROLES_BY_PROTOCOL_ID_STDDEV_SAMPLE_PROTOCOL_ID_DESC
  ROLES_BY_PROTOCOL_ID_SUM_ID_ASC
  ROLES_BY_PROTOCOL_ID_SUM_ID_DESC
  ROLES_BY_PROTOCOL_ID_SUM_PROTOCOL_ID_ASC
  ROLES_BY_PROTOCOL_ID_SUM_PROTOCOL_ID_DESC
  ROLES_BY_PROTOCOL_ID_VARIANCE_POPULATION_ID_ASC
  ROLES_BY_PROTOCOL_ID_VARIANCE_POPULATION_ID_DESC
  ROLES_BY_PROTOCOL_ID_VARIANCE_POPULATION_PROTOCOL_ID_ASC
  ROLES_BY_PROTOCOL_ID_VARIANCE_POPULATION_PROTOCOL_ID_DESC
  ROLES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_ID_ASC
  ROLES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_ID_DESC
  ROLES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_PROTOCOL_ID_ASC
  ROLES_BY_PROTOCOL_ID_VARIANCE_SAMPLE_PROTOCOL_ID_DESC
  TRACKS_BY_PROTOCOL_ID_AVERAGE_ID_ASC
  TRACKS_BY_PROTOCOL_ID_AVERAGE_ID_DESC
  TRACKS_BY_PROTOCOL_ID_AVERAGE_PROTOCOL_ID_ASC
  TRACKS_BY_PROTOCOL_ID_AVERAGE_PROTOCOL_ID_DESC
  TRACKS_BY_PROTOCOL_ID_AVERAGE_ROLE_ID_ASC
  TRACKS_BY_PROTOCOL_ID_AVERAGE_ROLE_ID_DESC
  TRACKS_BY_PROTOCOL_ID_COUNT_ASC
  TRACKS_BY_PROTOCOL_ID_COUNT_DESC
  TRACKS_BY_PROTOCOL_ID_DISTINCT_COUNT_ID_ASC
  TRACKS_BY_PROTOCOL_ID_DISTINCT_COUNT_ID_DESC
  TRACKS_BY_PROTOCOL_ID_DISTINCT_COUNT_PROTOCOL_ID_ASC
  TRACKS_BY_PROTOCOL_ID_DISTINCT_COUNT_PROTOCOL_ID_DESC
  TRACKS_BY_PROTOCOL_ID_DISTINCT_COUNT_ROLE_ID_ASC
  TRACKS_BY_PROTOCOL_ID_DISTINCT_COUNT_ROLE_ID_DESC
  TRACKS_BY_PROTOCOL_ID_MAX_ID_ASC
  TRACKS_BY_PROTOCOL_ID_MAX_ID_DESC
  TRACKS_BY_PROTOCOL_ID_MAX_PROTOCOL_ID_ASC
  TRACKS_BY_PROTOCOL_ID_MAX_PROTOCOL_ID_DESC
  TRACKS_BY_PROTOCOL_ID_MAX_ROLE_ID_ASC
  TRACKS_BY_PROTOCOL_ID_MAX_ROLE_ID_DESC
  TRACKS_BY_PROTOCOL_ID_MIN_ID_ASC
  TRACKS_BY_PROTOCOL_ID_MIN_ID_DESC
  TRACKS_BY_PROTOCOL_ID_MIN_PROTOCOL_ID_ASC
  TRACKS_BY_PROTOCOL_ID_MIN_PROTOCOL_ID_DESC
  TRACKS_BY_PROTOCOL_ID_MIN_ROLE_ID_ASC
  TRACKS_BY_PROTOCOL_ID_MIN_ROLE_ID_DESC
  TRACKS_BY_PROTOCOL_ID_STDDEV_POPULATION_ID_ASC
  TRACKS_BY_PROTOCOL_ID_STDDEV_POPULATION_ID_DESC
  TRACKS_BY_PROTOCOL_ID_STDDEV_POPULATION_PROTOCOL_ID_ASC
  TRACKS_BY_PROTOCOL_ID_STDDEV_POPULATION_PROTOCOL_ID_DESC
  TRACKS_BY_PROTOCOL_ID_STDDEV_POPULATION_ROLE_ID_ASC
  TRACKS_BY_PROTOCOL_ID_STDDEV_POPULATION_ROLE_ID_DESC
  TRACKS_BY_PROTOCOL_ID_STDDEV_SAMPLE_ID_ASC
  TRACKS_BY_PROTOCOL_ID_STDDEV_SAMPLE_ID_DESC
  TRACKS_BY_PROTOCOL_ID_STDDEV_SAMPLE_PROTOCOL_ID_ASC
  TRACKS_BY_PROTOCOL_ID_STDDEV_SAMPLE_PROTOCOL_ID_DESC
  TRACKS_BY_PROTOCOL_ID_STDDEV_SAMPLE_ROLE_ID_ASC
  TRACKS_BY_PROTOCOL_ID_STDDEV_SAMPLE_ROLE_ID_DESC
  TRACKS_BY_PROTOCOL_ID_SUM_ID_ASC
  TRACKS_BY_PROTOCOL_ID_SUM_ID_DESC
  TRACKS_BY_PROTOCOL_ID_SUM_PROTOCOL_ID_ASC
  TRACKS_BY_PROTOCOL_ID_SUM_PROTOCOL_ID_DESC
  TRACKS_BY_PROTOCOL_ID_SUM_ROLE_ID_ASC
  TRACKS_BY_PROTOCOL_ID_SUM_ROLE_ID_DESC
  TRACKS_BY_PROTOCOL_ID_VARIANCE_POPULATION_ID_ASC
  TRACKS_BY_PROTOCOL_ID_VARIANCE_POPULATION_ID_DESC
  TRACKS_BY_PROTOCOL_ID_VARIANCE_POPULATION_PROTOCOL_ID_ASC
  TRACKS_BY_PROTOCOL_ID_VARIANCE_POPULATION_PROTOCOL_ID_DESC
  TRACKS_BY_PROTOCOL_ID_VARIANCE_POPULATION_ROLE_ID_ASC
  TRACKS_BY_PROTOCOL_ID_VARIANCE_POPULATION_ROLE_ID_DESC
  TRACKS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_ID_ASC
  TRACKS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_ID_DESC
  TRACKS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_PROTOCOL_ID_ASC
  TRACKS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_PROTOCOL_ID_DESC
  TRACKS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_ROLE_ID_ASC
  TRACKS_BY_PROTOCOL_ID_VARIANCE_SAMPLE_ROLE_ID_DESC
}

"""
The root query type which gives access points into the data universe.
"""
type Query implements Node {
  """
  Reads and enables pagination through a set of `Definition`.
  """
  allDefinitions(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DefinitionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DefinitionFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Definition`.
    """
    orderBy: [DefinitionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): DefinitionsConnection

  """
  Reads a set of `Definition`.
  """
  allDefinitionsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DefinitionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DefinitionFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Skip the first `n` values.
    """
    offset: Int

    """
    The method to use when ordering `Definition`.
    """
    orderBy: [DefinitionsOrderBy!]
  ): [Definition!]

  """
  Reads and enables pagination through a set of `EarnedBadge`.
  """
  allEarnedBadges(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EarnedBadgeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EarnedBadgeFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `EarnedBadge`.
    """
    orderBy: [EarnedBadgesOrderBy!] = [PRIMARY_KEY_ASC]
  ): EarnedBadgesConnection

  """
  Reads a set of `EarnedBadge`.
  """
  allEarnedBadgesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EarnedBadgeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EarnedBadgeFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Skip the first `n` values.
    """
    offset: Int

    """
    The method to use when ordering `EarnedBadge`.
    """
    orderBy: [EarnedBadgesOrderBy!]
  ): [EarnedBadge!]

  """
  Reads and enables pagination through a set of `KnexMigration`.
  """
  allKnexMigrations(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: KnexMigrationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: KnexMigrationFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `KnexMigration`.
    """
    orderBy: [KnexMigrationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): KnexMigrationsConnection

  """
  Reads a set of `KnexMigration`.
  """
  allKnexMigrationsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: KnexMigrationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: KnexMigrationFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Skip the first `n` values.
    """
    offset: Int

    """
    The method to use when ordering `KnexMigration`.
    """
    orderBy: [KnexMigrationsOrderBy!]
  ): [KnexMigration!]

  """
  Reads and enables pagination through a set of `KnexMigrationsLock`.
  """
  allKnexMigrationsLocks(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: KnexMigrationsLockCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: KnexMigrationsLockFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `KnexMigrationsLock`.
    """
    orderBy: [KnexMigrationsLocksOrderBy!] = [PRIMARY_KEY_ASC]
  ): KnexMigrationsLocksConnection

  """
  Reads a set of `KnexMigrationsLock`.
  """
  allKnexMigrationsLocksList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: KnexMigrationsLockCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: KnexMigrationsLockFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Skip the first `n` values.
    """
    offset: Int

    """
    The method to use when ordering `KnexMigrationsLock`.
    """
    orderBy: [KnexMigrationsLocksOrderBy!]
  ): [KnexMigrationsLock!]

  """
  Reads and enables pagination through a set of `Protocol`.
  """
  allProtocols(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProtocolCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProtocolFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Protocol`.
    """
    orderBy: [ProtocolsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProtocolsConnection

  """
  Reads a set of `Protocol`.
  """
  allProtocolsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProtocolCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ProtocolFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Skip the first `n` values.
    """
    offset: Int

    """
    The method to use when ordering `Protocol`.
    """
    orderBy: [ProtocolsOrderBy!]
  ): [Protocol!]

  """
  Reads and enables pagination through a set of `Ranking`.
  """
  allRankings(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RankingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RankingFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Ranking`.
    """
    orderBy: [RankingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RankingsConnection

  """
  Reads a set of `Ranking`.
  """
  allRankingsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RankingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RankingFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Skip the first `n` values.
    """
    offset: Int

    """
    The method to use when ordering `Ranking`.
    """
    orderBy: [RankingsOrderBy!]
  ): [Ranking!]

  """
  Reads and enables pagination through a set of `Role`.
  """
  allRoles(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RoleCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RoleFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Role`.
    """
    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RolesConnection

  """
  Reads a set of `Role`.
  """
  allRolesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RoleCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RoleFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Skip the first `n` values.
    """
    offset: Int

    """
    The method to use when ordering `Role`.
    """
    orderBy: [RolesOrderBy!]
  ): [Role!]

  """
  Reads and enables pagination through a set of `Track`.
  """
  allTracks(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TrackCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TrackFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Track`.
    """
    orderBy: [TracksOrderBy!] = [PRIMARY_KEY_ASC]
  ): TracksConnection

  """
  Reads a set of `Track`.
  """
  allTracksList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TrackCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TrackFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Skip the first `n` values.
    """
    offset: Int

    """
    The method to use when ordering `Track`.
    """
    orderBy: [TracksOrderBy!]
  ): [Track!]

  """
  Reads and enables pagination through a set of `Winner`.
  """
  allWinners(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WinnerCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: WinnerFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Winner`.
    """
    orderBy: [WinnersOrderBy!] = [PRIMARY_KEY_ASC]
  ): WinnersConnection

  """
  Reads a set of `Winner`.
  """
  allWinnersList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WinnerCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: WinnerFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Skip the first `n` values.
    """
    offset: Int

    """
    The method to use when ordering `Winner`.
    """
    orderBy: [WinnersOrderBy!]
  ): [Winner!]

  """
  Reads a single `Definition` using its globally unique `ID`.
  """
  definition(
    """
    The globally unique `ID` to be used in selecting a single `Definition`.
    """
    nodeId: ID!
  ): Definition
  definitionById(id: String!): Definition
  definitionByIdAndProtocolId(id: String!, protocolId: String!): Definition

  """
  Reads a single `EarnedBadge` using its globally unique `ID`.
  """
  earnedBadge(
    """
    The globally unique `ID` to be used in selecting a single `EarnedBadge`.
    """
    nodeId: ID!
  ): EarnedBadge
  earnedBadgeById(id: String!): EarnedBadge

  """
  Reads a single `KnexMigration` using its globally unique `ID`.
  """
  knexMigration(
    """
    The globally unique `ID` to be used in selecting a single `KnexMigration`.
    """
    nodeId: ID!
  ): KnexMigration
  knexMigrationById(id: Int!): KnexMigration

  """
  Reads a single `KnexMigrationsLock` using its globally unique `ID`.
  """
  knexMigrationsLock(
    """
    The globally unique `ID` to be used in selecting a single `KnexMigrationsLock`.
    """
    nodeId: ID!
  ): KnexMigrationsLock
  knexMigrationsLockByIndex(index: Int!): KnexMigrationsLock

  """
  Fetches an object given its globally unique `ID`.
  """
  node(
    """
    The globally unique `ID`.
    """
    nodeId: ID!
  ): Node

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """
  Reads a single `Protocol` using its globally unique `ID`.
  """
  protocol(
    """
    The globally unique `ID` to be used in selecting a single `Protocol`.
    """
    nodeId: ID!
  ): Protocol
  protocolById(id: String!): Protocol

  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  Reads a single `Ranking` using its globally unique `ID`.
  """
  ranking(
    """
    The globally unique `ID` to be used in selecting a single `Ranking`.
    """
    nodeId: ID!
  ): Ranking
  rankingByWinnerIdAndProtocolId(
    protocolId: String!
    winnerId: String!
  ): Ranking

  """
  Reads a single `Role` using its globally unique `ID`.
  """
  role(
    """
    The globally unique `ID` to be used in selecting a single `Role`.
    """
    nodeId: ID!
  ): Role
  roleById(id: String!): Role
  roleByIdAndProtocolId(id: String!, protocolId: String!): Role

  """
  Reads a single `Track` using its globally unique `ID`.
  """
  track(
    """
    The globally unique `ID` to be used in selecting a single `Track`.
    """
    nodeId: ID!
  ): Track
  trackById(id: String!): Track

  """
  Reads a single `Winner` using its globally unique `ID`.
  """
  winner(
    """
    The globally unique `ID` to be used in selecting a single `Winner`.
    """
    nodeId: ID!
  ): Winner
  winnerById(id: String!): Winner
}

type Ranking implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Reads a single `Protocol` that is related to this `Ranking`.
  """
  protocolByProtocolId: Protocol
  protocolId: String!
  rank: Int!

  """
  Reads a single `Winner` that is related to this `Ranking`.
  """
  winnerByWinnerId: Winner
  winnerId: String!
}

type RankingAggregates {
  """
  Mean average aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  average: RankingAverageAggregates

  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: RankingDistinctCountAggregates
  keys: [String!]

  """
  Maximum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  max: RankingMaxAggregates

  """
  Minimum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  min: RankingMinAggregates

  """
  Population standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevPopulation: RankingStddevPopulationAggregates

  """
  Sample standard deviation aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  stddevSample: RankingStddevSampleAggregates

  """
  Sum aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  sum: RankingSumAggregates

  """
  Population variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  variancePopulation: RankingVariancePopulationAggregates

  """
  Sample variance aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  varianceSample: RankingVarianceSampleAggregates
}

"""
A filter to be used against aggregates of `Ranking` object types.
"""
input RankingAggregatesFilter {
  """
  Mean average aggregate over matching `Ranking` objects.
  """
  average: RankingAverageAggregateFilter

  """
  Distinct count aggregate over matching `Ranking` objects.
  """
  distinctCount: RankingDistinctCountAggregateFilter

  """
  A filter that must pass for the relevant `Ranking` object to be included within the aggregate.
  """
  filter: RankingFilter

  """
  Maximum aggregate over matching `Ranking` objects.
  """
  max: RankingMaxAggregateFilter

  """
  Minimum aggregate over matching `Ranking` objects.
  """
  min: RankingMinAggregateFilter

  """
  Population standard deviation aggregate over matching `Ranking` objects.
  """
  stddevPopulation: RankingStddevPopulationAggregateFilter

  """
  Sample standard deviation aggregate over matching `Ranking` objects.
  """
  stddevSample: RankingStddevSampleAggregateFilter

  """
  Sum aggregate over matching `Ranking` objects.
  """
  sum: RankingSumAggregateFilter

  """
  Population variance aggregate over matching `Ranking` objects.
  """
  variancePopulation: RankingVariancePopulationAggregateFilter

  """
  Sample variance aggregate over matching `Ranking` objects.
  """
  varianceSample: RankingVarianceSampleAggregateFilter
}

input RankingAverageAggregateFilter {
  rank: BigFloatFilter
}

type RankingAverageAggregates {
  """
  Mean average of rank across the matching connection
  """
  rank: BigFloat
}

"""
A condition to be used against `Ranking` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input RankingCondition {
  """
  Checks for equality with the object’s `protocolId` field.
  """
  protocolId: String

  """
  Checks for equality with the object’s `rank` field.
  """
  rank: Int

  """
  Checks for equality with the object’s `winnerId` field.
  """
  winnerId: String
}

input RankingDistinctCountAggregateFilter {
  protocolId: BigIntFilter
  rank: BigIntFilter
  winnerId: BigIntFilter
}

type RankingDistinctCountAggregates {
  """
  Distinct count of protocolId across the matching connection
  """
  protocolId: BigInt

  """
  Distinct count of rank across the matching connection
  """
  rank: BigInt

  """
  Distinct count of winnerId across the matching connection
  """
  winnerId: BigInt
}

"""
A filter to be used against `Ranking` object types. All fields are combined with a logical ‘and.’
"""
input RankingFilter {
  """
  Checks for all expressions in this list.
  """
  and: [RankingFilter!]

  """
  Negates the expression.
  """
  not: RankingFilter

  """
  Checks for any expressions in this list.
  """
  or: [RankingFilter!]

  """
  Filter by the object’s `protocolByProtocolId` relation.
  """
  protocolByProtocolId: ProtocolFilter

  """
  Filter by the object’s `protocolId` field.
  """
  protocolId: StringFilter

  """
  Filter by the object’s `rank` field.
  """
  rank: IntFilter

  """
  Filter by the object’s `winnerByWinnerId` relation.
  """
  winnerByWinnerId: WinnerFilter

  """
  Filter by the object’s `winnerId` field.
  """
  winnerId: StringFilter
}

input RankingMaxAggregateFilter {
  rank: IntFilter
}

type RankingMaxAggregates {
  """
  Maximum of rank across the matching connection
  """
  rank: Int
}

input RankingMinAggregateFilter {
  rank: IntFilter
}

type RankingMinAggregates {
  """
  Minimum of rank across the matching connection
  """
  rank: Int
}

input RankingStddevPopulationAggregateFilter {
  rank: BigFloatFilter
}

type RankingStddevPopulationAggregates {
  """
  Population standard deviation of rank across the matching connection
  """
  rank: BigFloat
}

input RankingStddevSampleAggregateFilter {
  rank: BigFloatFilter
}

type RankingStddevSampleAggregates {
  """
  Sample standard deviation of rank across the matching connection
  """
  rank: BigFloat
}

input RankingSumAggregateFilter {
  rank: BigIntFilter
}

type RankingSumAggregates {
  """
  Sum of rank across the matching connection
  """
  rank: BigInt!
}

input RankingVariancePopulationAggregateFilter {
  rank: BigFloatFilter
}

type RankingVariancePopulationAggregates {
  """
  Population variance of rank across the matching connection
  """
  rank: BigFloat
}

input RankingVarianceSampleAggregateFilter {
  rank: BigFloatFilter
}

type RankingVarianceSampleAggregates {
  """
  Sample variance of rank across the matching connection
  """
  rank: BigFloat
}

"""
A connection to a list of `Ranking` values.
"""
type RankingsConnection {
  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: RankingAggregates

  """
  A list of edges which contains the `Ranking` and cursor to aid in pagination.
  """
  edges: [RankingsEdge!]!

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `Ranking` for these aggregates.
    """
    groupBy: [RankingsGroupBy!]!

    """
    Conditions on the grouped aggregates.
    """
    having: RankingsHavingInput
  ): [RankingAggregates!]

  """
  A list of `Ranking` objects.
  """
  nodes: [Ranking!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Ranking` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Ranking` edge in the connection.
"""
type RankingsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Ranking` at the end of the edge.
  """
  node: Ranking!
}

"""
Grouping methods for `Ranking` for usage during aggregation.
"""
enum RankingsGroupBy {
  PROTOCOL_ID
  RANK
  WINNER_ID
}

input RankingsHavingAverageInput {
  rank: HavingIntFilter
}

input RankingsHavingDistinctCountInput {
  rank: HavingIntFilter
}

"""
Conditions for `Ranking` aggregates.
"""
input RankingsHavingInput {
  AND: [RankingsHavingInput!]
  OR: [RankingsHavingInput!]
  average: RankingsHavingAverageInput
  distinctCount: RankingsHavingDistinctCountInput
  max: RankingsHavingMaxInput
  min: RankingsHavingMinInput
  stddevPopulation: RankingsHavingStddevPopulationInput
  stddevSample: RankingsHavingStddevSampleInput
  sum: RankingsHavingSumInput
  variancePopulation: RankingsHavingVariancePopulationInput
  varianceSample: RankingsHavingVarianceSampleInput
}

input RankingsHavingMaxInput {
  rank: HavingIntFilter
}

input RankingsHavingMinInput {
  rank: HavingIntFilter
}

input RankingsHavingStddevPopulationInput {
  rank: HavingIntFilter
}

input RankingsHavingStddevSampleInput {
  rank: HavingIntFilter
}

input RankingsHavingSumInput {
  rank: HavingIntFilter
}

input RankingsHavingVariancePopulationInput {
  rank: HavingIntFilter
}

input RankingsHavingVarianceSampleInput {
  rank: HavingIntFilter
}

"""
Methods to use when ordering `Ranking`.
"""
enum RankingsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PROTOCOL_ID_ASC
  PROTOCOL_ID_DESC
  RANK_ASC
  RANK_DESC
  WINNER_ID_ASC
  WINNER_ID_DESC
}

type Role implements Node {
  id: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Reads a single `Protocol` that is related to this `Role`.
  """
  protocolByProtocolId: Protocol
  protocolId: String!

  """
  Reads and enables pagination through a set of `Track`.
  """
  tracksByRoleId(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TrackCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TrackFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Track`.
    """
    orderBy: [TracksOrderBy!] = [PRIMARY_KEY_ASC]
  ): TracksConnection!

  """
  Reads and enables pagination through a set of `Track`.
  """
  tracksByRoleIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TrackCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TrackFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Skip the first `n` values.
    """
    offset: Int

    """
    The method to use when ordering `Track`.
    """
    orderBy: [TracksOrderBy!]
  ): [Track!]!
}

type RoleAggregates {
  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: RoleDistinctCountAggregates
  keys: [String!]
}

"""
A filter to be used against aggregates of `Role` object types.
"""
input RoleAggregatesFilter {
  """
  Distinct count aggregate over matching `Role` objects.
  """
  distinctCount: RoleDistinctCountAggregateFilter

  """
  A filter that must pass for the relevant `Role` object to be included within the aggregate.
  """
  filter: RoleFilter
}

"""
A condition to be used against `Role` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input RoleCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: String

  """
  Checks for equality with the object’s `protocolId` field.
  """
  protocolId: String
}

input RoleDistinctCountAggregateFilter {
  id: BigIntFilter
  protocolId: BigIntFilter
}

type RoleDistinctCountAggregates {
  """
  Distinct count of id across the matching connection
  """
  id: BigInt

  """
  Distinct count of protocolId across the matching connection
  """
  protocolId: BigInt
}

"""
A filter to be used against `Role` object types. All fields are combined with a logical ‘and.’
"""
input RoleFilter {
  """
  Checks for all expressions in this list.
  """
  and: [RoleFilter!]

  """
  Filter by the object’s `id` field.
  """
  id: StringFilter

  """
  Negates the expression.
  """
  not: RoleFilter

  """
  Checks for any expressions in this list.
  """
  or: [RoleFilter!]

  """
  Filter by the object’s `protocolByProtocolId` relation.
  """
  protocolByProtocolId: ProtocolFilter

  """
  Filter by the object’s `protocolId` field.
  """
  protocolId: StringFilter

  """
  Filter by the object’s `tracksByRoleId` relation.
  """
  tracksByRoleId: RoleToManyTrackFilter

  """
  Some related `tracksByRoleId` exist.
  """
  tracksByRoleIdExist: Boolean
}

"""
A filter to be used against many `Track` object types. All fields are combined with a logical ‘and.’
"""
input RoleToManyTrackFilter {
  """
  Aggregates across related `Track` match the filter criteria.
  """
  aggregates: TrackAggregatesFilter

  """
  Every related `Track` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TrackFilter

  """
  No related `Track` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TrackFilter

  """
  Some related `Track` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TrackFilter
}

"""
A connection to a list of `Role` values.
"""
type RolesConnection {
  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: RoleAggregates

  """
  A list of edges which contains the `Role` and cursor to aid in pagination.
  """
  edges: [RolesEdge!]!

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `Role` for these aggregates.
    """
    groupBy: [RolesGroupBy!]!

    """
    Conditions on the grouped aggregates.
    """
    having: RolesHavingInput
  ): [RoleAggregates!]

  """
  A list of `Role` objects.
  """
  nodes: [Role!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Role` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Role` edge in the connection.
"""
type RolesEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Role` at the end of the edge.
  """
  node: Role!
}

"""
Grouping methods for `Role` for usage during aggregation.
"""
enum RolesGroupBy {
  PROTOCOL_ID
}

"""
Conditions for `Role` aggregates.
"""
input RolesHavingInput {
  AND: [RolesHavingInput!]
  OR: [RolesHavingInput!]
}

"""
Methods to use when ordering `Role`.
"""
enum RolesOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PROTOCOL_ID_ASC
  PROTOCOL_ID_DESC
  TRACKS_BY_ROLE_ID_AVERAGE_ID_ASC
  TRACKS_BY_ROLE_ID_AVERAGE_ID_DESC
  TRACKS_BY_ROLE_ID_AVERAGE_PROTOCOL_ID_ASC
  TRACKS_BY_ROLE_ID_AVERAGE_PROTOCOL_ID_DESC
  TRACKS_BY_ROLE_ID_AVERAGE_ROLE_ID_ASC
  TRACKS_BY_ROLE_ID_AVERAGE_ROLE_ID_DESC
  TRACKS_BY_ROLE_ID_COUNT_ASC
  TRACKS_BY_ROLE_ID_COUNT_DESC
  TRACKS_BY_ROLE_ID_DISTINCT_COUNT_ID_ASC
  TRACKS_BY_ROLE_ID_DISTINCT_COUNT_ID_DESC
  TRACKS_BY_ROLE_ID_DISTINCT_COUNT_PROTOCOL_ID_ASC
  TRACKS_BY_ROLE_ID_DISTINCT_COUNT_PROTOCOL_ID_DESC
  TRACKS_BY_ROLE_ID_DISTINCT_COUNT_ROLE_ID_ASC
  TRACKS_BY_ROLE_ID_DISTINCT_COUNT_ROLE_ID_DESC
  TRACKS_BY_ROLE_ID_MAX_ID_ASC
  TRACKS_BY_ROLE_ID_MAX_ID_DESC
  TRACKS_BY_ROLE_ID_MAX_PROTOCOL_ID_ASC
  TRACKS_BY_ROLE_ID_MAX_PROTOCOL_ID_DESC
  TRACKS_BY_ROLE_ID_MAX_ROLE_ID_ASC
  TRACKS_BY_ROLE_ID_MAX_ROLE_ID_DESC
  TRACKS_BY_ROLE_ID_MIN_ID_ASC
  TRACKS_BY_ROLE_ID_MIN_ID_DESC
  TRACKS_BY_ROLE_ID_MIN_PROTOCOL_ID_ASC
  TRACKS_BY_ROLE_ID_MIN_PROTOCOL_ID_DESC
  TRACKS_BY_ROLE_ID_MIN_ROLE_ID_ASC
  TRACKS_BY_ROLE_ID_MIN_ROLE_ID_DESC
  TRACKS_BY_ROLE_ID_STDDEV_POPULATION_ID_ASC
  TRACKS_BY_ROLE_ID_STDDEV_POPULATION_ID_DESC
  TRACKS_BY_ROLE_ID_STDDEV_POPULATION_PROTOCOL_ID_ASC
  TRACKS_BY_ROLE_ID_STDDEV_POPULATION_PROTOCOL_ID_DESC
  TRACKS_BY_ROLE_ID_STDDEV_POPULATION_ROLE_ID_ASC
  TRACKS_BY_ROLE_ID_STDDEV_POPULATION_ROLE_ID_DESC
  TRACKS_BY_ROLE_ID_STDDEV_SAMPLE_ID_ASC
  TRACKS_BY_ROLE_ID_STDDEV_SAMPLE_ID_DESC
  TRACKS_BY_ROLE_ID_STDDEV_SAMPLE_PROTOCOL_ID_ASC
  TRACKS_BY_ROLE_ID_STDDEV_SAMPLE_PROTOCOL_ID_DESC
  TRACKS_BY_ROLE_ID_STDDEV_SAMPLE_ROLE_ID_ASC
  TRACKS_BY_ROLE_ID_STDDEV_SAMPLE_ROLE_ID_DESC
  TRACKS_BY_ROLE_ID_SUM_ID_ASC
  TRACKS_BY_ROLE_ID_SUM_ID_DESC
  TRACKS_BY_ROLE_ID_SUM_PROTOCOL_ID_ASC
  TRACKS_BY_ROLE_ID_SUM_PROTOCOL_ID_DESC
  TRACKS_BY_ROLE_ID_SUM_ROLE_ID_ASC
  TRACKS_BY_ROLE_ID_SUM_ROLE_ID_DESC
  TRACKS_BY_ROLE_ID_VARIANCE_POPULATION_ID_ASC
  TRACKS_BY_ROLE_ID_VARIANCE_POPULATION_ID_DESC
  TRACKS_BY_ROLE_ID_VARIANCE_POPULATION_PROTOCOL_ID_ASC
  TRACKS_BY_ROLE_ID_VARIANCE_POPULATION_PROTOCOL_ID_DESC
  TRACKS_BY_ROLE_ID_VARIANCE_POPULATION_ROLE_ID_ASC
  TRACKS_BY_ROLE_ID_VARIANCE_POPULATION_ROLE_ID_DESC
  TRACKS_BY_ROLE_ID_VARIANCE_SAMPLE_ID_ASC
  TRACKS_BY_ROLE_ID_VARIANCE_SAMPLE_ID_DESC
  TRACKS_BY_ROLE_ID_VARIANCE_SAMPLE_PROTOCOL_ID_ASC
  TRACKS_BY_ROLE_ID_VARIANCE_SAMPLE_PROTOCOL_ID_DESC
  TRACKS_BY_ROLE_ID_VARIANCE_SAMPLE_ROLE_ID_ASC
  TRACKS_BY_ROLE_ID_VARIANCE_SAMPLE_ROLE_ID_DESC
}

"""
A filter to be used against String fields. All fields are combined with a logical ‘and.’
"""
input StringFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String

  """
  Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  distinctFromInsensitive: String

  """
  Ends with the specified string (case-sensitive).
  """
  endsWith: String

  """
  Ends with the specified string (case-insensitive).
  """
  endsWithInsensitive: String

  """
  Equal to the specified value.
  """
  equalTo: String

  """
  Equal to the specified value (case-insensitive).
  """
  equalToInsensitive: String

  """
  Greater than the specified value.
  """
  greaterThan: String

  """
  Greater than the specified value (case-insensitive).
  """
  greaterThanInsensitive: String

  """
  Greater than or equal to the specified value.
  """
  greaterThanOrEqualTo: String

  """
  Greater than or equal to the specified value (case-insensitive).
  """
  greaterThanOrEqualToInsensitive: String

  """
  Included in the specified list.
  """
  in: [String!]

  """
  Included in the specified list (case-insensitive).
  """
  inInsensitive: [String!]

  """
  Contains the specified string (case-sensitive).
  """
  includes: String

  """
  Contains the specified string (case-insensitive).
  """
  includesInsensitive: String

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """
  Less than the specified value.
  """
  lessThan: String

  """
  Less than the specified value (case-insensitive).
  """
  lessThanInsensitive: String

  """
  Less than or equal to the specified value.
  """
  lessThanOrEqualTo: String

  """
  Less than or equal to the specified value (case-insensitive).
  """
  lessThanOrEqualToInsensitive: String

  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String

  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String

  """
  Equal to the specified value, treating null like an ordinary value.
  """
  notDistinctFrom: String

  """
  Equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  notDistinctFromInsensitive: String

  """
  Does not end with the specified string (case-sensitive).
  """
  notEndsWith: String

  """
  Does not end with the specified string (case-insensitive).
  """
  notEndsWithInsensitive: String

  """
  Not equal to the specified value.
  """
  notEqualTo: String

  """
  Not equal to the specified value (case-insensitive).
  """
  notEqualToInsensitive: String

  """
  Not included in the specified list.
  """
  notIn: [String!]

  """
  Not included in the specified list (case-insensitive).
  """
  notInInsensitive: [String!]

  """
  Does not contain the specified string (case-sensitive).
  """
  notIncludes: String

  """
  Does not contain the specified string (case-insensitive).
  """
  notIncludesInsensitive: String

  """
  Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLike: String

  """
  Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLikeInsensitive: String

  """
  Does not start with the specified string (case-sensitive).
  """
  notStartsWith: String

  """
  Does not start with the specified string (case-insensitive).
  """
  notStartsWithInsensitive: String

  """
  Starts with the specified string (case-sensitive).
  """
  startsWith: String

  """
  Starts with the specified string (case-insensitive).
  """
  startsWithInsensitive: String
}

type Track implements Node {
  """
  Reads and enables pagination through a set of `Definition`.
  """
  definitionsByTrackId(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DefinitionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DefinitionFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Definition`.
    """
    orderBy: [DefinitionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): DefinitionsConnection!

  """
  Reads and enables pagination through a set of `Definition`.
  """
  definitionsByTrackIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DefinitionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DefinitionFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Skip the first `n` values.
    """
    offset: Int

    """
    The method to use when ordering `Definition`.
    """
    orderBy: [DefinitionsOrderBy!]
  ): [Definition!]!
  id: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Reads a single `Protocol` that is related to this `Track`.
  """
  protocolByProtocolId: Protocol
  protocolId: String!

  """
  Reads a single `Role` that is related to this `Track`.
  """
  roleByRoleId: Role
  roleId: String
}

type TrackAggregates {
  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: TrackDistinctCountAggregates
  keys: [String!]
}

"""
A filter to be used against aggregates of `Track` object types.
"""
input TrackAggregatesFilter {
  """
  Distinct count aggregate over matching `Track` objects.
  """
  distinctCount: TrackDistinctCountAggregateFilter

  """
  A filter that must pass for the relevant `Track` object to be included within the aggregate.
  """
  filter: TrackFilter
}

"""
A condition to be used against `Track` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input TrackCondition {
  """
  Checks for equality with the object’s `id` field.
  """
  id: String

  """
  Checks for equality with the object’s `protocolId` field.
  """
  protocolId: String

  """
  Checks for equality with the object’s `roleId` field.
  """
  roleId: String
}

input TrackDistinctCountAggregateFilter {
  id: BigIntFilter
  protocolId: BigIntFilter
  roleId: BigIntFilter
}

type TrackDistinctCountAggregates {
  """
  Distinct count of id across the matching connection
  """
  id: BigInt

  """
  Distinct count of protocolId across the matching connection
  """
  protocolId: BigInt

  """
  Distinct count of roleId across the matching connection
  """
  roleId: BigInt
}

"""
A filter to be used against `Track` object types. All fields are combined with a logical ‘and.’
"""
input TrackFilter {
  """
  Checks for all expressions in this list.
  """
  and: [TrackFilter!]

  """
  Filter by the object’s `definitionsByTrackId` relation.
  """
  definitionsByTrackId: TrackToManyDefinitionFilter

  """
  Some related `definitionsByTrackId` exist.
  """
  definitionsByTrackIdExist: Boolean

  """
  Filter by the object’s `id` field.
  """
  id: StringFilter

  """
  Negates the expression.
  """
  not: TrackFilter

  """
  Checks for any expressions in this list.
  """
  or: [TrackFilter!]

  """
  Filter by the object’s `protocolByProtocolId` relation.
  """
  protocolByProtocolId: ProtocolFilter

  """
  Filter by the object’s `protocolId` field.
  """
  protocolId: StringFilter

  """
  Filter by the object’s `roleByRoleId` relation.
  """
  roleByRoleId: RoleFilter

  """
  A related `roleByRoleId` exists.
  """
  roleByRoleIdExists: Boolean

  """
  Filter by the object’s `roleId` field.
  """
  roleId: StringFilter
}

"""
A filter to be used against many `Definition` object types. All fields are combined with a logical ‘and.’
"""
input TrackToManyDefinitionFilter {
  """
  Aggregates across related `Definition` match the filter criteria.
  """
  aggregates: DefinitionAggregatesFilter

  """
  Every related `Definition` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: DefinitionFilter

  """
  No related `Definition` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: DefinitionFilter

  """
  Some related `Definition` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: DefinitionFilter
}

"""
A connection to a list of `Track` values.
"""
type TracksConnection {
  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: TrackAggregates

  """
  A list of edges which contains the `Track` and cursor to aid in pagination.
  """
  edges: [TracksEdge!]!

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `Track` for these aggregates.
    """
    groupBy: [TracksGroupBy!]!

    """
    Conditions on the grouped aggregates.
    """
    having: TracksHavingInput
  ): [TrackAggregates!]

  """
  A list of `Track` objects.
  """
  nodes: [Track!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Track` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Track` edge in the connection.
"""
type TracksEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Track` at the end of the edge.
  """
  node: Track!
}

"""
Grouping methods for `Track` for usage during aggregation.
"""
enum TracksGroupBy {
  PROTOCOL_ID
  ROLE_ID
}

"""
Conditions for `Track` aggregates.
"""
input TracksHavingInput {
  AND: [TracksHavingInput!]
  OR: [TracksHavingInput!]
}

"""
Methods to use when ordering `Track`.
"""
enum TracksOrderBy {
  DEFINITIONS_BY_TRACK_ID_AVERAGE_DESCRIPTION_ASC
  DEFINITIONS_BY_TRACK_ID_AVERAGE_DESCRIPTION_DESC
  DEFINITIONS_BY_TRACK_ID_AVERAGE_ID_ASC
  DEFINITIONS_BY_TRACK_ID_AVERAGE_ID_DESC
  DEFINITIONS_BY_TRACK_ID_AVERAGE_IPFS_URI_ASC
  DEFINITIONS_BY_TRACK_ID_AVERAGE_IPFS_URI_DESC
  DEFINITIONS_BY_TRACK_ID_AVERAGE_LEVEL_ASC
  DEFINITIONS_BY_TRACK_ID_AVERAGE_LEVEL_DESC
  DEFINITIONS_BY_TRACK_ID_AVERAGE_METRIC_ASC
  DEFINITIONS_BY_TRACK_ID_AVERAGE_METRIC_DESC
  DEFINITIONS_BY_TRACK_ID_AVERAGE_PROTOCOL_ID_ASC
  DEFINITIONS_BY_TRACK_ID_AVERAGE_PROTOCOL_ID_DESC
  DEFINITIONS_BY_TRACK_ID_AVERAGE_THRESHOLD_ASC
  DEFINITIONS_BY_TRACK_ID_AVERAGE_THRESHOLD_DESC
  DEFINITIONS_BY_TRACK_ID_AVERAGE_TRACK_ID_ASC
  DEFINITIONS_BY_TRACK_ID_AVERAGE_TRACK_ID_DESC
  DEFINITIONS_BY_TRACK_ID_COUNT_ASC
  DEFINITIONS_BY_TRACK_ID_COUNT_DESC
  DEFINITIONS_BY_TRACK_ID_DISTINCT_COUNT_DESCRIPTION_ASC
  DEFINITIONS_BY_TRACK_ID_DISTINCT_COUNT_DESCRIPTION_DESC
  DEFINITIONS_BY_TRACK_ID_DISTINCT_COUNT_ID_ASC
  DEFINITIONS_BY_TRACK_ID_DISTINCT_COUNT_ID_DESC
  DEFINITIONS_BY_TRACK_ID_DISTINCT_COUNT_IPFS_URI_ASC
  DEFINITIONS_BY_TRACK_ID_DISTINCT_COUNT_IPFS_URI_DESC
  DEFINITIONS_BY_TRACK_ID_DISTINCT_COUNT_LEVEL_ASC
  DEFINITIONS_BY_TRACK_ID_DISTINCT_COUNT_LEVEL_DESC
  DEFINITIONS_BY_TRACK_ID_DISTINCT_COUNT_METRIC_ASC
  DEFINITIONS_BY_TRACK_ID_DISTINCT_COUNT_METRIC_DESC
  DEFINITIONS_BY_TRACK_ID_DISTINCT_COUNT_PROTOCOL_ID_ASC
  DEFINITIONS_BY_TRACK_ID_DISTINCT_COUNT_PROTOCOL_ID_DESC
  DEFINITIONS_BY_TRACK_ID_DISTINCT_COUNT_THRESHOLD_ASC
  DEFINITIONS_BY_TRACK_ID_DISTINCT_COUNT_THRESHOLD_DESC
  DEFINITIONS_BY_TRACK_ID_DISTINCT_COUNT_TRACK_ID_ASC
  DEFINITIONS_BY_TRACK_ID_DISTINCT_COUNT_TRACK_ID_DESC
  DEFINITIONS_BY_TRACK_ID_MAX_DESCRIPTION_ASC
  DEFINITIONS_BY_TRACK_ID_MAX_DESCRIPTION_DESC
  DEFINITIONS_BY_TRACK_ID_MAX_ID_ASC
  DEFINITIONS_BY_TRACK_ID_MAX_ID_DESC
  DEFINITIONS_BY_TRACK_ID_MAX_IPFS_URI_ASC
  DEFINITIONS_BY_TRACK_ID_MAX_IPFS_URI_DESC
  DEFINITIONS_BY_TRACK_ID_MAX_LEVEL_ASC
  DEFINITIONS_BY_TRACK_ID_MAX_LEVEL_DESC
  DEFINITIONS_BY_TRACK_ID_MAX_METRIC_ASC
  DEFINITIONS_BY_TRACK_ID_MAX_METRIC_DESC
  DEFINITIONS_BY_TRACK_ID_MAX_PROTOCOL_ID_ASC
  DEFINITIONS_BY_TRACK_ID_MAX_PROTOCOL_ID_DESC
  DEFINITIONS_BY_TRACK_ID_MAX_THRESHOLD_ASC
  DEFINITIONS_BY_TRACK_ID_MAX_THRESHOLD_DESC
  DEFINITIONS_BY_TRACK_ID_MAX_TRACK_ID_ASC
  DEFINITIONS_BY_TRACK_ID_MAX_TRACK_ID_DESC
  DEFINITIONS_BY_TRACK_ID_MIN_DESCRIPTION_ASC
  DEFINITIONS_BY_TRACK_ID_MIN_DESCRIPTION_DESC
  DEFINITIONS_BY_TRACK_ID_MIN_ID_ASC
  DEFINITIONS_BY_TRACK_ID_MIN_ID_DESC
  DEFINITIONS_BY_TRACK_ID_MIN_IPFS_URI_ASC
  DEFINITIONS_BY_TRACK_ID_MIN_IPFS_URI_DESC
  DEFINITIONS_BY_TRACK_ID_MIN_LEVEL_ASC
  DEFINITIONS_BY_TRACK_ID_MIN_LEVEL_DESC
  DEFINITIONS_BY_TRACK_ID_MIN_METRIC_ASC
  DEFINITIONS_BY_TRACK_ID_MIN_METRIC_DESC
  DEFINITIONS_BY_TRACK_ID_MIN_PROTOCOL_ID_ASC
  DEFINITIONS_BY_TRACK_ID_MIN_PROTOCOL_ID_DESC
  DEFINITIONS_BY_TRACK_ID_MIN_THRESHOLD_ASC
  DEFINITIONS_BY_TRACK_ID_MIN_THRESHOLD_DESC
  DEFINITIONS_BY_TRACK_ID_MIN_TRACK_ID_ASC
  DEFINITIONS_BY_TRACK_ID_MIN_TRACK_ID_DESC
  DEFINITIONS_BY_TRACK_ID_STDDEV_POPULATION_DESCRIPTION_ASC
  DEFINITIONS_BY_TRACK_ID_STDDEV_POPULATION_DESCRIPTION_DESC
  DEFINITIONS_BY_TRACK_ID_STDDEV_POPULATION_ID_ASC
  DEFINITIONS_BY_TRACK_ID_STDDEV_POPULATION_ID_DESC
  DEFINITIONS_BY_TRACK_ID_STDDEV_POPULATION_IPFS_URI_ASC
  DEFINITIONS_BY_TRACK_ID_STDDEV_POPULATION_IPFS_URI_DESC
  DEFINITIONS_BY_TRACK_ID_STDDEV_POPULATION_LEVEL_ASC
  DEFINITIONS_BY_TRACK_ID_STDDEV_POPULATION_LEVEL_DESC
  DEFINITIONS_BY_TRACK_ID_STDDEV_POPULATION_METRIC_ASC
  DEFINITIONS_BY_TRACK_ID_STDDEV_POPULATION_METRIC_DESC
  DEFINITIONS_BY_TRACK_ID_STDDEV_POPULATION_PROTOCOL_ID_ASC
  DEFINITIONS_BY_TRACK_ID_STDDEV_POPULATION_PROTOCOL_ID_DESC
  DEFINITIONS_BY_TRACK_ID_STDDEV_POPULATION_THRESHOLD_ASC
  DEFINITIONS_BY_TRACK_ID_STDDEV_POPULATION_THRESHOLD_DESC
  DEFINITIONS_BY_TRACK_ID_STDDEV_POPULATION_TRACK_ID_ASC
  DEFINITIONS_BY_TRACK_ID_STDDEV_POPULATION_TRACK_ID_DESC
  DEFINITIONS_BY_TRACK_ID_STDDEV_SAMPLE_DESCRIPTION_ASC
  DEFINITIONS_BY_TRACK_ID_STDDEV_SAMPLE_DESCRIPTION_DESC
  DEFINITIONS_BY_TRACK_ID_STDDEV_SAMPLE_ID_ASC
  DEFINITIONS_BY_TRACK_ID_STDDEV_SAMPLE_ID_DESC
  DEFINITIONS_BY_TRACK_ID_STDDEV_SAMPLE_IPFS_URI_ASC
  DEFINITIONS_BY_TRACK_ID_STDDEV_SAMPLE_IPFS_URI_DESC
  DEFINITIONS_BY_TRACK_ID_STDDEV_SAMPLE_LEVEL_ASC
  DEFINITIONS_BY_TRACK_ID_STDDEV_SAMPLE_LEVEL_DESC
  DEFINITIONS_BY_TRACK_ID_STDDEV_SAMPLE_METRIC_ASC
  DEFINITIONS_BY_TRACK_ID_STDDEV_SAMPLE_METRIC_DESC
  DEFINITIONS_BY_TRACK_ID_STDDEV_SAMPLE_PROTOCOL_ID_ASC
  DEFINITIONS_BY_TRACK_ID_STDDEV_SAMPLE_PROTOCOL_ID_DESC
  DEFINITIONS_BY_TRACK_ID_STDDEV_SAMPLE_THRESHOLD_ASC
  DEFINITIONS_BY_TRACK_ID_STDDEV_SAMPLE_THRESHOLD_DESC
  DEFINITIONS_BY_TRACK_ID_STDDEV_SAMPLE_TRACK_ID_ASC
  DEFINITIONS_BY_TRACK_ID_STDDEV_SAMPLE_TRACK_ID_DESC
  DEFINITIONS_BY_TRACK_ID_SUM_DESCRIPTION_ASC
  DEFINITIONS_BY_TRACK_ID_SUM_DESCRIPTION_DESC
  DEFINITIONS_BY_TRACK_ID_SUM_ID_ASC
  DEFINITIONS_BY_TRACK_ID_SUM_ID_DESC
  DEFINITIONS_BY_TRACK_ID_SUM_IPFS_URI_ASC
  DEFINITIONS_BY_TRACK_ID_SUM_IPFS_URI_DESC
  DEFINITIONS_BY_TRACK_ID_SUM_LEVEL_ASC
  DEFINITIONS_BY_TRACK_ID_SUM_LEVEL_DESC
  DEFINITIONS_BY_TRACK_ID_SUM_METRIC_ASC
  DEFINITIONS_BY_TRACK_ID_SUM_METRIC_DESC
  DEFINITIONS_BY_TRACK_ID_SUM_PROTOCOL_ID_ASC
  DEFINITIONS_BY_TRACK_ID_SUM_PROTOCOL_ID_DESC
  DEFINITIONS_BY_TRACK_ID_SUM_THRESHOLD_ASC
  DEFINITIONS_BY_TRACK_ID_SUM_THRESHOLD_DESC
  DEFINITIONS_BY_TRACK_ID_SUM_TRACK_ID_ASC
  DEFINITIONS_BY_TRACK_ID_SUM_TRACK_ID_DESC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_POPULATION_DESCRIPTION_ASC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_POPULATION_DESCRIPTION_DESC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_POPULATION_ID_ASC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_POPULATION_ID_DESC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_POPULATION_IPFS_URI_ASC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_POPULATION_IPFS_URI_DESC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_POPULATION_LEVEL_ASC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_POPULATION_LEVEL_DESC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_POPULATION_METRIC_ASC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_POPULATION_METRIC_DESC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_POPULATION_PROTOCOL_ID_ASC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_POPULATION_PROTOCOL_ID_DESC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_POPULATION_THRESHOLD_ASC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_POPULATION_THRESHOLD_DESC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_POPULATION_TRACK_ID_ASC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_POPULATION_TRACK_ID_DESC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_SAMPLE_DESCRIPTION_ASC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_SAMPLE_DESCRIPTION_DESC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_SAMPLE_ID_ASC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_SAMPLE_ID_DESC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_SAMPLE_IPFS_URI_ASC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_SAMPLE_IPFS_URI_DESC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_SAMPLE_LEVEL_ASC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_SAMPLE_LEVEL_DESC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_SAMPLE_METRIC_ASC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_SAMPLE_METRIC_DESC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_SAMPLE_PROTOCOL_ID_ASC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_SAMPLE_PROTOCOL_ID_DESC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_SAMPLE_THRESHOLD_ASC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_SAMPLE_THRESHOLD_DESC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_SAMPLE_TRACK_ID_ASC
  DEFINITIONS_BY_TRACK_ID_VARIANCE_SAMPLE_TRACK_ID_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PROTOCOL_ID_ASC
  PROTOCOL_ID_DESC
  ROLE_ID_ASC
  ROLE_ID_DESC
}

type Winner implements Node {
  defaultDisplayName: String

  """
  Reads and enables pagination through a set of `EarnedBadge`.
  """
  earnedBadgesByWinnerId(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EarnedBadgeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EarnedBadgeFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `EarnedBadge`.
    """
    orderBy: [EarnedBadgesOrderBy!] = [PRIMARY_KEY_ASC]
  ): EarnedBadgesConnection!

  """
  Reads and enables pagination through a set of `EarnedBadge`.
  """
  earnedBadgesByWinnerIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EarnedBadgeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EarnedBadgeFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Skip the first `n` values.
    """
    offset: Int

    """
    The method to use when ordering `EarnedBadge`.
    """
    orderBy: [EarnedBadgesOrderBy!]
  ): [EarnedBadge!]!
  ens: String
  id: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Reads and enables pagination through a set of `Ranking`.
  """
  rankingsByWinnerId(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RankingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RankingFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Ranking`.
    """
    orderBy: [RankingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RankingsConnection!

  """
  Reads and enables pagination through a set of `Ranking`.
  """
  rankingsByWinnerIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RankingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RankingFilter

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Skip the first `n` values.
    """
    offset: Int

    """
    The method to use when ordering `Ranking`.
    """
    orderBy: [RankingsOrderBy!]
  ): [Ranking!]!
}

type WinnerAggregates {
  """
  Distinct count aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  distinctCount: WinnerDistinctCountAggregates
  keys: [String!]
}

"""
A condition to be used against `Winner` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input WinnerCondition {
  """
  Checks for equality with the object’s `defaultDisplayName` field.
  """
  defaultDisplayName: String

  """
  Checks for equality with the object’s `ens` field.
  """
  ens: String

  """
  Checks for equality with the object’s `id` field.
  """
  id: String
}

type WinnerDistinctCountAggregates {
  """
  Distinct count of defaultDisplayName across the matching connection
  """
  defaultDisplayName: BigInt

  """
  Distinct count of ens across the matching connection
  """
  ens: BigInt

  """
  Distinct count of id across the matching connection
  """
  id: BigInt
}

"""
A filter to be used against `Winner` object types. All fields are combined with a logical ‘and.’
"""
input WinnerFilter {
  """
  Checks for all expressions in this list.
  """
  and: [WinnerFilter!]

  """
  Filter by the object’s `defaultDisplayName` field.
  """
  defaultDisplayName: StringFilter

  """
  Filter by the object’s `earnedBadgesByWinnerId` relation.
  """
  earnedBadgesByWinnerId: WinnerToManyEarnedBadgeFilter

  """
  Some related `earnedBadgesByWinnerId` exist.
  """
  earnedBadgesByWinnerIdExist: Boolean

  """
  Filter by the object’s `ens` field.
  """
  ens: StringFilter

  """
  Filter by the object’s `id` field.
  """
  id: StringFilter

  """
  Negates the expression.
  """
  not: WinnerFilter

  """
  Checks for any expressions in this list.
  """
  or: [WinnerFilter!]

  """
  Filter by the object’s `rankingsByWinnerId` relation.
  """
  rankingsByWinnerId: WinnerToManyRankingFilter

  """
  Some related `rankingsByWinnerId` exist.
  """
  rankingsByWinnerIdExist: Boolean
}

"""
A filter to be used against many `EarnedBadge` object types. All fields are combined with a logical ‘and.’
"""
input WinnerToManyEarnedBadgeFilter {
  """
  Aggregates across related `EarnedBadge` match the filter criteria.
  """
  aggregates: EarnedBadgeAggregatesFilter

  """
  Every related `EarnedBadge` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: EarnedBadgeFilter

  """
  No related `EarnedBadge` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: EarnedBadgeFilter

  """
  Some related `EarnedBadge` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: EarnedBadgeFilter
}

"""
A filter to be used against many `Ranking` object types. All fields are combined with a logical ‘and.’
"""
input WinnerToManyRankingFilter {
  """
  Aggregates across related `Ranking` match the filter criteria.
  """
  aggregates: RankingAggregatesFilter

  """
  Every related `Ranking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: RankingFilter

  """
  No related `Ranking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: RankingFilter

  """
  Some related `Ranking` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: RankingFilter
}

"""
A connection to a list of `Winner` values.
"""
type WinnersConnection {
  """
  Aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  aggregates: WinnerAggregates

  """
  A list of edges which contains the `Winner` and cursor to aid in pagination.
  """
  edges: [WinnersEdge!]!

  """
  Grouped aggregates across the matching connection (ignoring before/after/first/last/offset)
  """
  groupedAggregates(
    """
    The method to use when grouping `Winner` for these aggregates.
    """
    groupBy: [WinnersGroupBy!]!

    """
    Conditions on the grouped aggregates.
    """
    having: WinnersHavingInput
  ): [WinnerAggregates!]

  """
  A list of `Winner` objects.
  """
  nodes: [Winner!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Winner` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Winner` edge in the connection.
"""
type WinnersEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Winner` at the end of the edge.
  """
  node: Winner!
}

"""
Grouping methods for `Winner` for usage during aggregation.
"""
enum WinnersGroupBy {
  DEFAULT_DISPLAY_NAME
  ENS
}

"""
Conditions for `Winner` aggregates.
"""
input WinnersHavingInput {
  AND: [WinnersHavingInput!]
  OR: [WinnersHavingInput!]
}

"""
Methods to use when ordering `Winner`.
"""
enum WinnersOrderBy {
  DEFAULT_DISPLAY_NAME_ASC
  DEFAULT_DISPLAY_NAME_DESC
  EARNED_BADGES_BY_WINNER_ID_AVERAGE_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_WINNER_ID_AVERAGE_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_WINNER_ID_AVERAGE_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_WINNER_ID_AVERAGE_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_WINNER_ID_AVERAGE_DEFINITION_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_AVERAGE_DEFINITION_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_AVERAGE_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_WINNER_ID_AVERAGE_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_WINNER_ID_AVERAGE_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_AVERAGE_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_AVERAGE_METADATA_ASC
  EARNED_BADGES_BY_WINNER_ID_AVERAGE_METADATA_DESC
  EARNED_BADGES_BY_WINNER_ID_AVERAGE_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_AVERAGE_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_AVERAGE_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_WINNER_ID_AVERAGE_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_WINNER_ID_AVERAGE_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_WINNER_ID_AVERAGE_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_WINNER_ID_AVERAGE_WINNER_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_AVERAGE_WINNER_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_COUNT_ASC
  EARNED_BADGES_BY_WINNER_ID_COUNT_DESC
  EARNED_BADGES_BY_WINNER_ID_DISTINCT_COUNT_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_WINNER_ID_DISTINCT_COUNT_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_WINNER_ID_DISTINCT_COUNT_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_WINNER_ID_DISTINCT_COUNT_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_WINNER_ID_DISTINCT_COUNT_DEFINITION_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_DISTINCT_COUNT_DEFINITION_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_DISTINCT_COUNT_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_WINNER_ID_DISTINCT_COUNT_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_WINNER_ID_DISTINCT_COUNT_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_DISTINCT_COUNT_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_DISTINCT_COUNT_METADATA_ASC
  EARNED_BADGES_BY_WINNER_ID_DISTINCT_COUNT_METADATA_DESC
  EARNED_BADGES_BY_WINNER_ID_DISTINCT_COUNT_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_DISTINCT_COUNT_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_DISTINCT_COUNT_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_WINNER_ID_DISTINCT_COUNT_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_WINNER_ID_DISTINCT_COUNT_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_WINNER_ID_DISTINCT_COUNT_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_WINNER_ID_DISTINCT_COUNT_WINNER_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_DISTINCT_COUNT_WINNER_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_MAX_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_WINNER_ID_MAX_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_WINNER_ID_MAX_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_WINNER_ID_MAX_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_WINNER_ID_MAX_DEFINITION_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_MAX_DEFINITION_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_MAX_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_WINNER_ID_MAX_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_WINNER_ID_MAX_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_MAX_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_MAX_METADATA_ASC
  EARNED_BADGES_BY_WINNER_ID_MAX_METADATA_DESC
  EARNED_BADGES_BY_WINNER_ID_MAX_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_MAX_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_MAX_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_WINNER_ID_MAX_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_WINNER_ID_MAX_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_WINNER_ID_MAX_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_WINNER_ID_MAX_WINNER_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_MAX_WINNER_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_MIN_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_WINNER_ID_MIN_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_WINNER_ID_MIN_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_WINNER_ID_MIN_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_WINNER_ID_MIN_DEFINITION_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_MIN_DEFINITION_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_MIN_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_WINNER_ID_MIN_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_WINNER_ID_MIN_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_MIN_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_MIN_METADATA_ASC
  EARNED_BADGES_BY_WINNER_ID_MIN_METADATA_DESC
  EARNED_BADGES_BY_WINNER_ID_MIN_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_MIN_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_MIN_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_WINNER_ID_MIN_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_WINNER_ID_MIN_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_WINNER_ID_MIN_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_WINNER_ID_MIN_WINNER_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_MIN_WINNER_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_POPULATION_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_POPULATION_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_POPULATION_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_POPULATION_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_POPULATION_DEFINITION_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_POPULATION_DEFINITION_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_POPULATION_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_POPULATION_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_POPULATION_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_POPULATION_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_POPULATION_METADATA_ASC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_POPULATION_METADATA_DESC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_POPULATION_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_POPULATION_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_POPULATION_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_POPULATION_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_POPULATION_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_POPULATION_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_POPULATION_WINNER_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_POPULATION_WINNER_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_SAMPLE_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_SAMPLE_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_SAMPLE_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_SAMPLE_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_SAMPLE_DEFINITION_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_SAMPLE_DEFINITION_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_SAMPLE_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_SAMPLE_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_SAMPLE_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_SAMPLE_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_SAMPLE_METADATA_ASC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_SAMPLE_METADATA_DESC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_SAMPLE_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_SAMPLE_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_SAMPLE_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_SAMPLE_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_SAMPLE_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_SAMPLE_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_SAMPLE_WINNER_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_STDDEV_SAMPLE_WINNER_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_SUM_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_WINNER_ID_SUM_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_WINNER_ID_SUM_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_WINNER_ID_SUM_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_WINNER_ID_SUM_DEFINITION_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_SUM_DEFINITION_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_SUM_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_WINNER_ID_SUM_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_WINNER_ID_SUM_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_SUM_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_SUM_METADATA_ASC
  EARNED_BADGES_BY_WINNER_ID_SUM_METADATA_DESC
  EARNED_BADGES_BY_WINNER_ID_SUM_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_SUM_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_SUM_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_WINNER_ID_SUM_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_WINNER_ID_SUM_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_WINNER_ID_SUM_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_WINNER_ID_SUM_WINNER_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_SUM_WINNER_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_POPULATION_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_POPULATION_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_POPULATION_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_POPULATION_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_POPULATION_DEFINITION_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_POPULATION_DEFINITION_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_POPULATION_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_POPULATION_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_POPULATION_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_POPULATION_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_POPULATION_METADATA_ASC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_POPULATION_METADATA_DESC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_POPULATION_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_POPULATION_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_POPULATION_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_POPULATION_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_POPULATION_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_POPULATION_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_POPULATION_WINNER_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_POPULATION_WINNER_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_SAMPLE_AWARD_NUMBER_ASC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_SAMPLE_AWARD_NUMBER_DESC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_SAMPLE_BLOCK_AWARDED_ASC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_SAMPLE_BLOCK_AWARDED_DESC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_SAMPLE_DEFINITION_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_SAMPLE_DEFINITION_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_SAMPLE_GLOBAL_BADGE_NUMBER_ASC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_SAMPLE_GLOBAL_BADGE_NUMBER_DESC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_SAMPLE_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_SAMPLE_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_SAMPLE_METADATA_ASC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_SAMPLE_METADATA_DESC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_SAMPLE_PROTOCOL_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_SAMPLE_PROTOCOL_ID_DESC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_SAMPLE_TIMESTAMP_AWARDED_ASC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_SAMPLE_TIMESTAMP_AWARDED_DESC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_SAMPLE_TRANSACTION_HASH_ASC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_SAMPLE_TRANSACTION_HASH_DESC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_SAMPLE_WINNER_ID_ASC
  EARNED_BADGES_BY_WINNER_ID_VARIANCE_SAMPLE_WINNER_ID_DESC
  ENS_ASC
  ENS_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RANKINGS_BY_WINNER_ID_AVERAGE_PROTOCOL_ID_ASC
  RANKINGS_BY_WINNER_ID_AVERAGE_PROTOCOL_ID_DESC
  RANKINGS_BY_WINNER_ID_AVERAGE_RANK_ASC
  RANKINGS_BY_WINNER_ID_AVERAGE_RANK_DESC
  RANKINGS_BY_WINNER_ID_AVERAGE_WINNER_ID_ASC
  RANKINGS_BY_WINNER_ID_AVERAGE_WINNER_ID_DESC
  RANKINGS_BY_WINNER_ID_COUNT_ASC
  RANKINGS_BY_WINNER_ID_COUNT_DESC
  RANKINGS_BY_WINNER_ID_DISTINCT_COUNT_PROTOCOL_ID_ASC
  RANKINGS_BY_WINNER_ID_DISTINCT_COUNT_PROTOCOL_ID_DESC
  RANKINGS_BY_WINNER_ID_DISTINCT_COUNT_RANK_ASC
  RANKINGS_BY_WINNER_ID_DISTINCT_COUNT_RANK_DESC
  RANKINGS_BY_WINNER_ID_DISTINCT_COUNT_WINNER_ID_ASC
  RANKINGS_BY_WINNER_ID_DISTINCT_COUNT_WINNER_ID_DESC
  RANKINGS_BY_WINNER_ID_MAX_PROTOCOL_ID_ASC
  RANKINGS_BY_WINNER_ID_MAX_PROTOCOL_ID_DESC
  RANKINGS_BY_WINNER_ID_MAX_RANK_ASC
  RANKINGS_BY_WINNER_ID_MAX_RANK_DESC
  RANKINGS_BY_WINNER_ID_MAX_WINNER_ID_ASC
  RANKINGS_BY_WINNER_ID_MAX_WINNER_ID_DESC
  RANKINGS_BY_WINNER_ID_MIN_PROTOCOL_ID_ASC
  RANKINGS_BY_WINNER_ID_MIN_PROTOCOL_ID_DESC
  RANKINGS_BY_WINNER_ID_MIN_RANK_ASC
  RANKINGS_BY_WINNER_ID_MIN_RANK_DESC
  RANKINGS_BY_WINNER_ID_MIN_WINNER_ID_ASC
  RANKINGS_BY_WINNER_ID_MIN_WINNER_ID_DESC
  RANKINGS_BY_WINNER_ID_STDDEV_POPULATION_PROTOCOL_ID_ASC
  RANKINGS_BY_WINNER_ID_STDDEV_POPULATION_PROTOCOL_ID_DESC
  RANKINGS_BY_WINNER_ID_STDDEV_POPULATION_RANK_ASC
  RANKINGS_BY_WINNER_ID_STDDEV_POPULATION_RANK_DESC
  RANKINGS_BY_WINNER_ID_STDDEV_POPULATION_WINNER_ID_ASC
  RANKINGS_BY_WINNER_ID_STDDEV_POPULATION_WINNER_ID_DESC
  RANKINGS_BY_WINNER_ID_STDDEV_SAMPLE_PROTOCOL_ID_ASC
  RANKINGS_BY_WINNER_ID_STDDEV_SAMPLE_PROTOCOL_ID_DESC
  RANKINGS_BY_WINNER_ID_STDDEV_SAMPLE_RANK_ASC
  RANKINGS_BY_WINNER_ID_STDDEV_SAMPLE_RANK_DESC
  RANKINGS_BY_WINNER_ID_STDDEV_SAMPLE_WINNER_ID_ASC
  RANKINGS_BY_WINNER_ID_STDDEV_SAMPLE_WINNER_ID_DESC
  RANKINGS_BY_WINNER_ID_SUM_PROTOCOL_ID_ASC
  RANKINGS_BY_WINNER_ID_SUM_PROTOCOL_ID_DESC
  RANKINGS_BY_WINNER_ID_SUM_RANK_ASC
  RANKINGS_BY_WINNER_ID_SUM_RANK_DESC
  RANKINGS_BY_WINNER_ID_SUM_WINNER_ID_ASC
  RANKINGS_BY_WINNER_ID_SUM_WINNER_ID_DESC
  RANKINGS_BY_WINNER_ID_VARIANCE_POPULATION_PROTOCOL_ID_ASC
  RANKINGS_BY_WINNER_ID_VARIANCE_POPULATION_PROTOCOL_ID_DESC
  RANKINGS_BY_WINNER_ID_VARIANCE_POPULATION_RANK_ASC
  RANKINGS_BY_WINNER_ID_VARIANCE_POPULATION_RANK_DESC
  RANKINGS_BY_WINNER_ID_VARIANCE_POPULATION_WINNER_ID_ASC
  RANKINGS_BY_WINNER_ID_VARIANCE_POPULATION_WINNER_ID_DESC
  RANKINGS_BY_WINNER_ID_VARIANCE_SAMPLE_PROTOCOL_ID_ASC
  RANKINGS_BY_WINNER_ID_VARIANCE_SAMPLE_PROTOCOL_ID_DESC
  RANKINGS_BY_WINNER_ID_VARIANCE_SAMPLE_RANK_ASC
  RANKINGS_BY_WINNER_ID_VARIANCE_SAMPLE_RANK_DESC
  RANKINGS_BY_WINNER_ID_VARIANCE_SAMPLE_WINNER_ID_ASC
  RANKINGS_BY_WINNER_ID_VARIANCE_SAMPLE_WINNER_ID_DESC
}
